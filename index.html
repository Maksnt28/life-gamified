<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Life Gamified</title>

    <!-- PWA: manifest + iOS Home Screen install support -->
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Life Gamified">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">

    <style>
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* ========== Notification / Install Banner ========== */
        #notif-banner {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 9999;
            background: #111;
            border-bottom: 1px solid #222;
            padding: 0.7rem 1rem;
            animation: notifSlideDown 0.28s cubic-bezier(.22,.68,0,1.2);
        }
        @keyframes notifSlideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to   { transform: translateY(0);     opacity: 1; }
        }
        .notif-banner-row {
            display: flex;
            align-items: center;
            gap: 0.65rem;
            max-width: 560px;
            margin: 0 auto;
        }
        .notif-banner-icon { font-size: 1.3rem; flex-shrink: 0; }
        .notif-banner-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }
        .notif-banner-text strong {
            font-size: 0.8rem;
            color: #e5e5e5;
            font-weight: 600;
        }
        .notif-banner-text span {
            font-size: 0.7rem;
            color: #666;
            line-height: 1.35;
        }
        .notif-banner-btn {
            background: #fff;
            color: #0a0a0a;
            border: none;
            border-radius: 6px;
            padding: 0.38rem 0.7rem;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
            white-space: nowrap;
            transition: opacity 0.15s;
        }
        .notif-banner-btn:active { opacity: 0.7; }
        .notif-banner-close {
            background: none;
            border: none;
            color: #444;
            font-size: 1rem;
            line-height: 1;
            cursor: pointer;
            padding: 0.2rem 0.25rem;
            border-radius: 4px;
            flex-shrink: 0;
            transition: color 0.15s;
        }
        .notif-banner-close:active { color: #999; }
        /* ================================================== */

        body {
            min-height: 100vh;
            background: #0a0a0a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            color: #e5e5e5;
            padding: 0;
            padding-bottom: 5rem;
            overflow-x: hidden;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* Sticky Header */
        .sticky-header {
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            background: #0a0a0a;
            z-index: 100;
            padding: 1rem 1rem 0;
            margin: 0 -1rem;
            width: calc(100% + 2rem);
        }

        .sticky-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #1a1a1a, transparent);
        }

        .main-content {
            padding-top: 0.75rem;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 0.75rem;
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 0.25rem;
            letter-spacing: -0.02em;
        }

        .app-subtitle {
            color: #525252;
            font-size: 0.8rem;
            font-weight: 400;
        }

        /* Level Progress */
        .level-container {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .level-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.8rem;
            color: #737373;
        }

        .level-badge {
            color: #a3a3a3;
            font-weight: 500;
        }

        .level-badge span {
            color: #ffffff;
            font-weight: 600;
        }

        .xp-text {
            color: #525252;
        }

        .progress-bar-container {
            width: 200px;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            border-radius: 2px;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
            width: 0%;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent 0%,
                transparent 25%,
                rgba(255, 255, 255, 0.4) 50%,
                transparent 75%,
                transparent 100%
            );
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Glow effect when near level-up (>90%) */
        .progress-bar.near-levelup {
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.6), 0 0 16px rgba(59, 130, 246, 0.3);
        }

        .progress-bar.near-levelup::after {
            animation-duration: 1.2s;
        }

        /* Date Navigation */
        .date-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin: 0.75rem 0;
            padding: 0 3.5rem;
        }

        .date-nav-center {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .today-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .nav-arrow {
            width: 32px;
            height: 32px;
            background: transparent;
            border: 1px solid #262626;
            border-radius: 8px;
            color: #525252;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (hover: hover) {
            .nav-arrow:hover {
                border-color: #404040;
                color: #a3a3a3;
                background: #141414;
            }
        }

        /* Elegant Date Display */
        .date-display-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            border-radius: 10px;
            min-width: 140px;
        }

        /* Day View: Prominent single date */
        .date-badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.125rem;
        }

        .date-badge-month {
            font-size: 0.55rem;
            font-weight: 600;
            color: #3b82f6;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .date-badge-day {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffffff;
            line-height: 1;
        }

        .date-badge-weekday {
            font-size: 0.6rem;
            font-weight: 500;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Week/Month View: Simple text */
        .date-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #e5e5e5;
            text-align: center;
        }

        .date-text-sub {
            font-size: 0.65rem;
            color: #525252;
            margin-top: 0.125rem;
        }

        .today-btn {
            padding: 0.375rem 0.625rem;
            background: transparent;
            border: 1px solid #262626;
            border-radius: 6px;
            color: #525252;
            font-size: 0.65rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        @media (hover: hover) {
            .today-btn:hover {
                border-color: #404040;
                color: #a3a3a3;
                background: #141414;
            }
        }

        .today-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
        }

        /* View Toggle */
        .view-toggle-container {
            display: flex;
            justify-content: center;
            padding-bottom: 0.75rem;
        }

        .view-toggle {
            display: flex;
            background: #141414;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 4px;
            gap: 2px;
        }

        .view-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            background: transparent;
            color: #525252;
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @media (min-width: 400px) {
            .view-btn {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }
        }

        @media (hover: hover) {
            .view-btn:hover {
                color: #737373;
            }
        }

        .view-btn:active {
            transform: scale(0.95);
        }

        .view-btn.active {
            background: #262626;
            color: #e5e5e5;
        }

        /* Day View - Optimized for fast switching */
        /* View Transition Animation */
        .view-container {
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .view-container.active {
            display: block;
            opacity: 1;
        }

        .view-container.fade-out {
            opacity: 0;
        }

        .view-container.fade-in {
            display: block;
            animation: viewFadeIn 0.2s ease forwards;
        }

        @keyframes viewFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Skeleton Loading States */
        .skeleton-row {
            height: 44px;
            background: linear-gradient(90deg, #1a1a1a 0%, #252525 50%, #1a1a1a 100%);
            background-size: 200% 100%;
            border-radius: 8px;
            margin-bottom: 8px;
            animation: skeletonShimmer 1.2s ease-in-out infinite;
        }

        .skeleton-row:last-child {
            width: 70%;
        }

        @keyframes skeletonShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .month-skeleton-container {
            padding: 1rem;
            opacity: 0;
            animation: skeletonFadeIn 0.15s ease forwards;
        }

        @keyframes skeletonFadeIn {
            to { opacity: 1; }
        }

        /* Quick-add Loading State */
        .plan-input-wrapper.loading .plan-inline-input {
            opacity: 0.5;
            pointer-events: none;
        }

        .plan-input-wrapper.loading .plan-gear-btn {
            display: none;
        }

        .plan-input-spinner {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            animation: inputSpinner 0.6s linear infinite;
            display: none;
        }

        .plan-input-wrapper.loading .plan-input-spinner {
            display: block;
        }

        @keyframes inputSpinner {
            to { transform: translateY(-50%) rotate(360deg); }
        }

        .day-view-container {
            display: none;
            content-visibility: auto;
        }

        .day-view-container.active {
            display: block;
        }

        .day-content {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            padding: 1rem;
            min-height: 300px;
        }

        .day-content.slide-left,
        .day-timeline-container.slide-left {
            animation: slideOutLeft 0.2s ease;
        }

        .day-content.slide-right,
        .day-timeline-container.slide-right {
            animation: slideOutRight 0.2s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(0);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOutLeft {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(-30px);
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(30px);
            }
        }

        .day-tasks {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Click-to-add area for Day view */
        .day-content {
            cursor: pointer;
        }

        .day-add-hint {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            margin-top: 0.5rem;
            border: 1px dashed #262626;
            border-radius: 8px;
            color: #333333;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        @media (hover: hover) {
            .day-add-hint:hover {
                border-color: #404040;
                color: #525252;
            }
        }

        /* Day View Timeline */
        .day-timeline-container {
            position: relative;
            height: calc(100vh - 180px);
            min-height: 500px;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            background: #0a0a0a;
            border-radius: 12px;
            border: 1px solid #1a1a1a;
        }

        .day-timeline {
            position: relative;
            height: 1440px; /* 24 hours × 60px */
            width: 100%;
        }

        .timeline-hour {
            position: absolute;
            left: 0;
            right: 0;
            height: 60px;
            border-bottom: 1px solid #1a1a1a;
        }

        .timeline-hour:nth-child(odd) {
            background: #0a0a0a;
        }

        .timeline-hour:nth-child(even) {
            background: #050505;
        }

        .timeline-hour-label {
            position: absolute;
            left: 8px;
            top: -8px;
            font-size: 11px;
            color: #525252;
            font-family: -apple-system, BlinkMacSystemFont, monospace;
            user-select: none;
            z-index: 1;
        }

        .timeline-hour:first-child .timeline-hour-label {
            top: 4px;
        }

        .timeline-current-time {
            position: absolute;
            left: 40px;
            right: 0;
            height: 2px;
            background: #ef4444;
            z-index: 10;
            pointer-events: none;
        }

        .timeline-current-time::before {
            content: '';
            position: absolute;
            left: -6px;
            top: -4px;
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
        }

        .timeline-tasks-layer {
            position: absolute;
            top: 0;
            left: 48px;
            right: 8px;
            bottom: 0;
            pointer-events: none;
        }

        .timeline-task-block {
            position: absolute;
            left: 0;
            width: 100%;
            min-height: 40px;
            border-left: 3px solid #3b82f6;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            z-index: 2;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .timeline-task-block:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 5;
        }

        .timeline-task-block.completed {
            opacity: 0.5;
        }

        .timeline-task-block .task-block-header {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: rgba(255,255,255,0.7);
        }

        .timeline-task-block .task-block-time {
            font-weight: 500;
        }

        .timeline-task-block .task-block-duration {
            opacity: 0.7;
        }

        .timeline-task-block .task-block-recurring {
            font-size: 12px;
            opacity: 0.7;
        }

        .timeline-task-block .task-block-name {
            font-size: 14px;
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-task-block.completed .task-block-name {
            opacity: 0.6;
        }

        .timeline-task-block.pressing {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        .timeline-task-block .task-block-checkbox {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 18px;
            height: 18px;
            min-width: 16px;
            min-height: 16px;
            border: 2px solid #404040;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            flex-shrink: 0;
        }

        .timeline-task-block .task-block-checkbox:hover {
            border-color: #666;
            background: rgba(0, 0, 0, 0.6);
            transform: scale(1.1);
        }

        .timeline-task-block .task-block-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .timeline-task-block .task-block-checkbox.checked::after {
            content: '';
            width: 7px;
            height: 5px;
            border-left: 2px solid #fff;
            border-bottom: 2px solid #fff;
            transform: rotate(-45deg);
            margin-top: -1px;
        }

        /* For very short tasks (< 40px height), use smaller checkbox */
        .timeline-task-block.compact .task-block-checkbox {
            width: 16px;
            height: 16px;
            top: 4px;
            right: 4px;
        }

        .timeline-task-block.compact .task-block-checkbox.checked::after {
            width: 6px;
            height: 4px;
        }

        .timeline-task-block .task-block-notes {
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        /* Short blocks (< 60px) - compact layout */
        .timeline-task-block.compact {
            padding: 4px 8px;
            gap: 0;
        }

        .timeline-task-block.compact .task-block-header {
            font-size: 10px;
        }

        .timeline-task-block.compact .task-block-name {
            font-size: 12px;
        }

        .timeline-task-block.compact .task-block-notes {
            display: none;
        }

        /* Overlapping task blocks */
        .timeline-task-block.overlapping {
            position: absolute;
        }

        .timeline-task-block.overlapping::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 152, 0, 0.15);
            border-radius: 6px;
            pointer-events: none;
            z-index: 0;
        }

        .timeline-task-block .overlap-warning {
            position: absolute;
            top: 4px;
            right: 6px;
            font-size: 12px;
            cursor: help;
            z-index: 3;
            opacity: 0.9;
        }

        .timeline-task-block .overlap-warning::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            right: 0;
            background: #262626;
            color: #e5e5e5;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            z-index: 100;
            margin-top: 4px;
            max-width: 200px;
            white-space: normal;
        }

        .timeline-task-block .overlap-warning:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Ensure content is above the orange overlay */
        .timeline-task-block.overlapping .task-block-header,
        .timeline-task-block.overlapping .task-block-name,
        .timeline-task-block.overlapping .task-block-notes {
            position: relative;
            z-index: 1;
        }

        /* Untimed tasks section - sticky at top of timeline */
        .timeline-untimed-section {
            position: sticky;
            top: 0;
            background: #0a0a0a;
            border-bottom: 1px solid #262626;
            padding: 12px;
            z-index: 30;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .timeline-untimed-section.has-tasks {
            display: block;
        }

        .timeline-untimed-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .untimed-count-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 20px;
            padding: 0 6px;
            background: #262626;
            border-radius: 10px;
            font-size: 12px;
            color: #999;
        }

        .timeline-untimed-tasks {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .timeline-untimed-task {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #141414;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .timeline-untimed-task:hover {
            background: #1a1a1a;
        }

        .timeline-untimed-task.completed {
            opacity: 0.6;
        }

        .timeline-untimed-task .task-checkbox {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .timeline-untimed-task .category-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .timeline-untimed-task .task-name {
            font-size: 14px;
            color: #e5e5e5;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .timeline-untimed-task.completed .task-name {
            text-decoration: line-through;
            color: #666;
        }

        .timeline-untimed-task .delete-button {
            opacity: 0;
            background: none;
            border: none;
            color: #666;
            font-size: 18px;
            cursor: pointer;
            padding: 0 4px;
            transition: opacity 0.15s ease, color 0.15s ease;
        }

        .timeline-untimed-task:hover .delete-button {
            opacity: 1;
        }

        .timeline-untimed-task .delete-button:hover {
            color: #ef4444;
        }

        /* Day view add hint in timeline */
        .timeline-add-hint {
            position: absolute;
            bottom: 8px;
            left: 48px;
            right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border: 1px dashed #262626;
            border-radius: 6px;
            color: #333;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 5;
        }

        .timeline-add-hint:hover {
            border-color: #404040;
            color: #525252;
        }

        /* Week View - 7-column timeline scheduler */
        .week-view-container {
            display: none;
            content-visibility: auto;
        }

        .week-view-container.active {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Mobile-only elements - hidden on desktop */
        .week-day-headers,
        .week-scroll-container,
        .week-timeline-content,
        .week-days-grid,
        .week-hour-markers,
        .week-header-corner {
            display: none;
        }

        /* Week Untimed Tasks Container (above timeline) */
        .week-untimed-container {
            background: #0d0d0d;
            border: 1px solid #1a1a1a;
            border-radius: 10px;
            padding: 12px;
            display: none;
        }

        .week-untimed-container.has-tasks {
            display: block;
        }

        .week-untimed-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1a1a1a;
        }

        .week-untimed-title {
            font-size: 13px;
            font-weight: 600;
            color: #a3a3a3;
        }

        .week-untimed-count {
            font-size: 11px;
            font-weight: 600;
            color: #525252;
            background: #1a1a1a;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .week-untimed-days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }

        .week-untimed-day {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .week-untimed-day.empty {
            display: none;
        }

        .week-untimed-day-header {
            font-size: 10px;
            font-weight: 600;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .week-untimed-day.today .week-untimed-day-header {
            color: #3b82f6;
        }

        .week-untimed-day-count {
            font-size: 9px;
            color: #404040;
            font-weight: normal;
        }

        .week-untimed-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: #141414;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .week-untimed-item:hover {
            background: #1a1a1a;
        }

        .week-untimed-item.completed {
            opacity: 0.5;
        }

        .week-untimed-item .item-checkbox {
            width: 14px;
            height: 14px;
            border: 2px solid #404040;
            border-radius: 3px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .week-untimed-item .item-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .week-untimed-item .item-checkbox.checked::after {
            content: '';
            width: 6px;
            height: 4px;
            border-left: 2px solid #fff;
            border-bottom: 2px solid #fff;
            transform: rotate(-45deg);
            margin-top: -1px;
        }

        .week-untimed-item .item-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .week-untimed-item .item-name {
            flex: 1;
            font-size: 12px;
            color: #e5e5e5;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .week-untimed-item.completed .item-name {
            opacity: 0.6;
            color: #666;
        }

        /* Mobile: Horizontally scrollable week with all 7 days visible */
        @media (max-width: 768px) {
            /* Untimed tasks - horizontal scroll matching day columns */
            .week-untimed-container {
                padding: 8px;
                border-radius: 8px;
            }

            .week-untimed-header {
                margin-bottom: 8px;
                padding-bottom: 6px;
            }

            .week-untimed-days {
                display: flex;
                overflow-x: auto;
                gap: 8px;
                padding-bottom: 4px;
                scroll-snap-type: x proximity;
                -webkit-overflow-scrolling: touch;
            }

            .week-untimed-day {
                flex: 0 0 112px;
                min-width: 112px;
                scroll-snap-align: start;
            }

            .week-untimed-day.empty {
                display: flex;
                opacity: 0.5;
            }

            .week-untimed-day-header {
                font-size: 10px;
            }

            .week-untimed-item {
                padding: 4px 6px;
            }

            .week-untimed-item .item-checkbox {
                width: 12px;
                height: 12px;
            }

            .week-untimed-item .item-dot {
                width: 5px;
                height: 5px;
            }

            .week-untimed-item .item-name {
                font-size: 11px;
            }
        }

        /* Week Timeline Wrapper - transparent on desktop */
        .week-timeline-wrapper {
            flex: 1;
            min-height: 0;
        }

        /* Week Timeline Grid - 7 columns on desktop */
        .week-timeline-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: #1a1a1a;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            height: calc(100vh - 180px);
            min-height: 500px;
        }

        /* Each day column */
        .week-day-column {
            display: flex;
            flex-direction: column;
            background: #0a0a0a;
            overflow: hidden;
        }

        .week-day-column.today {
            background: rgba(59, 130, 246, 0.02);
        }

        /* Sticky day header */
        .week-column-header {
            position: sticky;
            top: 0;
            z-index: 15;
            background: #0a0a0a;
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid #1a1a1a;
            flex-shrink: 0;
        }

        .week-day-column.today .week-column-header {
            background: rgba(59, 130, 246, 0.1);
            border-bottom-color: rgba(59, 130, 246, 0.3);
        }

        .week-column-day-name {
            font-size: 10px;
            font-weight: 600;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .week-day-column.today .week-column-day-name {
            color: #3b82f6;
        }

        .week-column-day-num {
            font-size: 16px;
            font-weight: 700;
            color: #a3a3a3;
            margin-top: 2px;
        }

        .week-day-column.today .week-column-day-num {
            color: #3b82f6;
        }

        /* Timeline scroll container within each column */
        .week-column-timeline {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            -webkit-overscroll-behavior: contain;
        }

        /* Timeline content (24 hours) */
        .week-column-hours {
            position: relative;
            height: 1440px; /* 24 hours × 60px */
            width: 100%;
        }

        /* Hour row in week column */
        .week-hour-row {
            position: absolute;
            left: 0;
            right: 0;
            height: 60px;
            border-bottom: 1px solid #141414;
        }

        .week-hour-row:nth-child(odd) {
            background: rgba(10, 10, 10, 0.5);
        }

        .week-hour-row:nth-child(even) {
            background: rgba(5, 5, 5, 0.5);
        }

        /* Hour label - only show on first column or every few hours */
        .week-hour-label {
            position: absolute;
            left: 2px;
            top: -6px;
            font-size: 9px;
            color: #404040;
            font-family: -apple-system, BlinkMacSystemFont, monospace;
            user-select: none;
            z-index: 1;
        }

        .week-hour-row:first-child .week-hour-label {
            top: 2px;
        }

        /* Tasks layer in week column */
        .week-tasks-layer {
            position: absolute;
            top: 0;
            left: 4px;
            right: 4px;
            bottom: 0;
            pointer-events: none;
        }

        /* Task block in week column - compact version */
        .week-task-block {
            position: absolute;
            left: 0;
            width: 100%;
            /* left and width overridden by JS for overlap handling */
            min-height: 20px;
            border-left: 2px solid #3b82f6;
            border-radius: 3px;
            padding: 2px 4px;
            cursor: pointer;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            z-index: 2;
            font-size: 10px;
        }

        .week-task-block:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            z-index: 5;
        }

        .week-task-block.completed {
            opacity: 0.5;
        }

        .week-task-block.pressing {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        .week-task-block .task-block-name {
            font-size: 10px;
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }

        .week-task-block.completed .task-block-name {
            opacity: 0.6;
        }

        .week-task-block .task-block-time {
            font-size: 8px;
            color: rgba(255,255,255,0.6);
            white-space: nowrap;
        }

        .week-task-block .task-block-checkbox {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 14px;
            height: 14px;
            border: 2px solid #404040;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .week-task-block .task-block-checkbox:hover {
            border-color: #666;
            background: rgba(0, 0, 0, 0.6);
            transform: scale(1.15);
        }

        .week-task-block .task-block-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .week-task-block .task-block-checkbox.checked::after {
            content: '';
            width: 5px;
            height: 3px;
            border-left: 2px solid #fff;
            border-bottom: 2px solid #fff;
            transform: rotate(-45deg);
            margin-top: -1px;
        }

        /* Overlapping task blocks in week - narrower columns */
        .week-task-block.overlapping::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 152, 0, 0.15);
            border-radius: 3px;
            pointer-events: none;
            z-index: 0;
        }

        .week-task-block .task-block-name,
        .week-task-block .task-block-time {
            position: relative;
            z-index: 1;
        }

        /* Warning icon for overlapping tasks */
        .week-overlap-warning {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 8px;
            line-height: 1;
            z-index: 2;
            opacity: 0.8;
        }

        /* Current time indicator in week columns */
        .week-current-time {
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: #ef4444;
            z-index: 10;
            pointer-events: none;
        }

        .week-current-time::before {
            content: '';
            position: absolute;
            left: -3px;
            top: -3px;
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
        }

        /* Mobile: Day and Week view with proper styling */
        @media (max-width: 768px) {
            /* ============ MOBILE DAY VIEW ============ */
            /* Match Week view's 50px per hour for consistency */
            .day-timeline {
                height: 1200px; /* 24 hours × 50px */
            }

            .timeline-hour {
                height: 50px;
            }

            .day-timeline-container {
                height: calc(100vh - 200px);
                min-height: 400px;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: auto; /* Prevent jerky momentum scrolling */
                overscroll-behavior: contain;
            }

            /* Adjust task block positioning for 50px hours */
            .timeline-task-block {
                min-height: 30px;
            }

            /* Current time indicator position scales with 50px hours */
            .timeline-current-time {
                /* Position calculated in JS based on hour height */
            }

            /* ============ MOBILE WEEK VIEW ============ */
            /* Week view container */
            .week-view-container.active {
                display: flex;
                flex-direction: column;
                gap: 0;
                overflow: visible; /* CRITICAL: Must NOT be hidden - breaks sticky positioning */
                height: calc(100vh - 180px); /* Container needs height for flex children */
            }

            /* Main scroll container - THIS is the scroll parent for sticky elements */
            .week-scroll-container {
                display: block;
                position: relative;
                height: calc(100vh - 280px); /* CRITICAL: Must have explicit height for sticky to work */
                min-height: 300px;
                overflow: auto; /* CRITICAL: Must be auto or scroll */
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                background: #0a0a0a;
                border-radius: 8px;
                touch-action: pan-x pan-y;
                /* NOTE: Do NOT use transform - it breaks sticky positioning */
            }

            /* STICKY DAY HEADERS - sticks to top when scrolling down */
            .week-day-headers {
                position: -webkit-sticky; /* Safari support */
                position: sticky;
                top: 0; /* CRITICAL: Stick to top edge */
                z-index: 30;
                display: grid;
                grid-template-columns: 50px repeat(7, 1fr); /* CRITICAL: 1fr for perfect alignment */
                background: linear-gradient(180deg, #1a1a1a 0%, #161616 100%);
                border-bottom: 2px solid #2a2a2a;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
                gap: 0;
                width: 100%;
                min-height: 60px;
            }

            /* Corner cell - sticky both top AND left */
            .week-header-corner {
                display: block;
                width: 50px;
                min-width: 50px;
                height: 60px;
                background: linear-gradient(135deg, #1a1a1a 0%, #141414 100%);
                position: sticky;
                left: 0;
                z-index: 35;
                border-right: 1px solid #2a2a2a;
            }

            /* Day header cells */
            .week-day-header-cell {
                height: 60px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border-right: 1px solid #2a2a2a;
                background: linear-gradient(180deg, #1a1a1a 0%, #161616 100%);
                min-width: 0; /* Allow flex shrinking */
                transition: all 0.2s ease;
            }

            .week-day-header-cell:last-child {
                border-right: none;
            }

            .week-day-header-cell:hover {
                background: linear-gradient(180deg, #222 0%, #1a1a1a 100%);
            }

            /* Today's header - blue gradient highlight */
            .week-day-header-cell.today {
                background: linear-gradient(180deg, #1e3a5f 0%, #16304d 100%);
                border-right: 1px solid #2d5a8a;
            }

            .week-day-header-cell.today:hover {
                background: linear-gradient(180deg, #234770 0%, #1a3858 100%);
            }

            .week-day-header-name {
                font-size: 11px;
                font-weight: 600;
                color: #888;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .week-day-header-cell.today .week-day-header-name {
                color: #5b9bd5;
            }

            .week-day-header-num {
                font-size: 22px;
                font-weight: 700;
                color: #fff;
                margin-top: 4px;
            }

            .week-day-header-cell.today .week-day-header-num {
                color: #fff;
                text-shadow: 0 0 8px rgba(91, 155, 213, 0.4);
            }

            /* Weekend header cells - slightly muted */
            .week-day-header-cell.weekend {
                background: linear-gradient(180deg, #161616 0%, #131313 100%);
            }

            .week-day-header-cell.weekend .week-day-header-name {
                color: #666;
            }

            .week-day-header-cell.weekend .week-day-header-num {
                color: #bbb;
            }

            /* Timeline content - grid with hours column + days grid */
            .week-timeline-content {
                display: grid;
                grid-template-columns: 50px 1fr; /* CRITICAL: 50px must match header corner */
                gap: 0;
                min-width: 100%;
            }

            /* STICKY HOUR MARKERS - sticks to left when scrolling right */
            .week-hour-markers {
                display: block;
                position: sticky;
                left: 0;
                z-index: 20;
                background: linear-gradient(90deg, #1a1a1a 0%, #161616 100%);
                width: 50px;
                min-width: 50px;
                border-right: 2px solid #2a2a2a;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
            }

            .week-hour-marker {
                height: 50px;
                display: flex;
                align-items: flex-start;
                justify-content: center;
                padding-top: 6px;
                font-size: 10px;
                font-weight: 500;
                color: #666;
                border-bottom: 1px solid #1a1a1a;
                box-sizing: border-box;
                background: linear-gradient(90deg, #1a1a1a 0%, #161616 100%);
                transition: all 0.2s ease;
            }

            .week-hour-marker:hover {
                background: linear-gradient(90deg, #222 0%, #1a1a1a 100%);
                color: #888;
            }

            /* Business hours highlighting (9 AM - 5 PM) - subtle emphasis */
            .week-hour-marker.business-hours {
                color: #888;
                background: linear-gradient(90deg, #1c1c1c 0%, #181818 100%);
            }

            /* Days grid - 7 columns using 1fr for perfect alignment */
            .week-days-grid {
                display: grid;
                grid-template-columns: repeat(7, 1fr); /* CRITICAL: Must match header (7 × 1fr) */
                gap: 0;
            }

            /* Individual day column */
            .week-day-column {
                position: relative;
                height: 1200px; /* 24 hours × 50px */
                border-right: 1px solid #1a1a1a;
                background: #0a0a0a;
                box-sizing: border-box;
                min-width: 0; /* Allow flex shrinking */
                transition: background 0.2s ease;
            }

            .week-day-column:last-child {
                border-right: none;
            }

            .week-day-column:hover {
                background: #0d0d0d;
            }

            /* Today's column - subtle blue tint */
            .week-day-column.today {
                background: linear-gradient(180deg, #0d1418 0%, #0a0a0a 100%);
                border-right: 1px solid #1e3a5f;
            }

            .week-day-column.today:hover {
                background: linear-gradient(180deg, #0f1820 0%, #0c0c0c 100%);
            }

            /* Weekend columns - slightly darker */
            .week-day-column.weekend {
                background: #08090a;
            }

            .week-day-column.weekend:hover {
                background: #0b0c0d;
            }

            /* Hour grid lines in day columns */
            .week-day-column::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 49px,
                    #151515 49px,
                    #151515 50px
                );
                pointer-events: none;
            }

            /* Major hour lines (every 3 hours) */
            .week-day-column::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 149px,
                    #1a1a1a 149px,
                    #1a1a1a 150px
                );
                pointer-events: none;
                z-index: 1;
            }

            /* Hide old elements */
            .week-column-header,
            .week-hour-label,
            .week-column-timeline,
            .week-column-hours,
            .week-timeline-wrapper,
            .week-timeline-grid {
                display: none !important;
            }

            /* Task blocks - positioned absolutely in day columns */
            .week-task-block {
                position: absolute;
                left: 2px;
                right: 2px;
                border-radius: 3px;
                padding: 3px 4px;
                font-size: 10px;
                color: #fff;
                cursor: pointer;
                overflow: hidden;
                min-height: 18px;
                box-sizing: border-box;
            }

            .week-task-block .task-block-name {
                font-size: 9px;
                font-weight: 500;
                line-height: 1.2;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .week-task-block .task-block-time {
                font-size: 8px;
                color: rgba(255, 255, 255, 0.7);
                margin-top: 1px;
            }

            /* Current time indicator */
            .week-current-time {
                position: absolute;
                left: 0;
                right: 0;
                height: 2px;
                background: #ef4444;
                z-index: 10;
                pointer-events: none;
            }

            .week-current-time::before {
                content: '';
                position: absolute;
                left: -3px;
                top: -3px;
                width: 8px;
                height: 8px;
                background: #ef4444;
                border-radius: 50%;
            }

            /* Hide navigation arrows on mobile for Week view */
            body[data-view="week"] .nav-arrow {
                display: none !important;
            }
        }

        /* Very small mobile screens - smaller hour column, smaller fonts */
        @media (max-width: 400px) {
            .week-day-headers {
                grid-template-columns: 40px repeat(7, 1fr);
            }

            .week-header-corner {
                width: 40px;
                min-width: 40px;
                height: 50px;
            }

            .week-day-header-cell {
                height: 50px;
            }

            .week-timeline-content {
                grid-template-columns: 40px 1fr;
            }

            .week-hour-markers {
                width: 40px;
                min-width: 40px;
            }

            .week-hour-marker {
                height: 50px;
                font-size: 9px;
                padding: 4px 4px;
            }

            .week-day-column {
                height: 1200px;
            }

            .week-day-column::after {
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 49px,
                    #151515 49px,
                    #151515 50px
                );
            }

            .week-day-column::before {
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 149px,
                    #1a1a1a 149px,
                    #1a1a1a 150px
                );
            }

            .week-untimed-day {
                flex: 0 0 80px;
                min-width: 80px;
            }

            .week-day-header-name {
                font-size: 9px;
            }

            .week-day-header-num {
                font-size: 16px;
            }

            .week-task-block .task-block-name {
                font-size: 8px;
            }
        }

        /* Large desktop - taller timeline */
        @media (min-width: 1200px) {
            .week-timeline-grid {
                height: calc(100vh - 160px);
            }
        }

        /* Responsive: Keep old media query structure for nav arrows */
        @media (max-width: 599px) {
            /* Hide navigation arrows on mobile for Day/Week views (swipe gestures exist) */
            body[data-view="day"] .nav-arrow {
                display: none !important;
            }
        }

        @media (min-width: 769px) {
            /* Show the mobile week structure on desktop too */
            .week-view-container.active {
                display: flex;
                flex-direction: column;
                gap: 0;
                overflow: visible;
                height: calc(100vh - 200px);
            }

            .week-scroll-container {
                display: block;
                position: relative;
                height: calc(100vh - 280px);
                min-height: 400px;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
                overscroll-behavior: contain;
                background: #0a0a0a;
                border-radius: 8px;
            }

            .week-day-headers {
                position: -webkit-sticky;
                position: sticky;
                top: 0;
                z-index: 30;
                display: grid;
                grid-template-columns: 60px repeat(7, 1fr);
                background: linear-gradient(180deg, #1a1a1a 0%, #161616 100%);
                border-bottom: 2px solid #2a2a2a;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
                gap: 0;
                width: 100%;
                min-height: 70px;
            }

            .week-header-corner {
                display: block;
                width: 60px;
                min-width: 60px;
                height: 70px;
                background: linear-gradient(135deg, #1a1a1a 0%, #141414 100%);
                position: sticky;
                left: 0;
                z-index: 35;
                border-right: 1px solid #2a2a2a;
            }

            .week-day-header-cell {
                height: 70px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border-right: 1px solid #2a2a2a;
                background: linear-gradient(180deg, #1a1a1a 0%, #161616 100%);
                min-width: 0;
                transition: all 0.2s ease;
            }

            .week-day-header-cell:last-child {
                border-right: none;
            }

            .week-day-header-cell:hover {
                background: linear-gradient(180deg, #222 0%, #1a1a1a 100%);
            }

            .week-day-header-cell.today {
                background: linear-gradient(180deg, #1e3a5f 0%, #16304d 100%);
                border-right: 1px solid #2d5a8a;
            }

            .week-day-header-name {
                font-size: 12px;
                font-weight: 600;
                color: #888;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .week-day-header-num {
                font-size: 26px;
                font-weight: 700;
                color: #fff;
                margin-top: 4px;
            }

            .week-timeline-content {
                display: grid;
                grid-template-columns: 60px 1fr;
                gap: 0;
                min-width: 100%;
            }

            .week-hour-markers {
                display: block;
                position: sticky;
                left: 0;
                z-index: 20;
                background: linear-gradient(90deg, #1a1a1a 0%, #161616 100%);
                width: 60px;
                min-width: 60px;
                border-right: 2px solid #2a2a2a;
                box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
            }

            .week-hour-marker {
                height: 60px;
                display: flex;
                align-items: flex-start;
                justify-content: center;
                padding-top: 6px;
                font-size: 11px;
                font-weight: 500;
                color: #666;
                transition: color 0.2s ease;
            }

            .week-hour-marker:hover {
                color: #888;
            }

            .week-days-grid {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 0;
            }

            .week-day-column {
                position: relative;
                height: 1440px; /* 24 hours × 60px */
                border-right: 1px solid #1a1a1a;
                background: #0a0a0a;
                box-sizing: border-box;
                min-width: 0;
                transition: background 0.2s ease;
            }

            .week-day-column:last-child {
                border-right: none;
            }

            .week-day-column::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 59px,
                    #151515 59px,
                    #151515 60px
                );
                pointer-events: none;
            }

            .week-day-column::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image: repeating-linear-gradient(
                    to bottom,
                    transparent 0,
                    transparent 179px,
                    #1a1a1a 179px,
                    #1a1a1a 180px
                );
                pointer-events: none;
                z-index: 1;
            }

            /* Hide old desktop elements */
            .week-timeline-grid,
            .week-grid {
                display: none !important;
            }

            /* Desktop untimed tasks - 7-column grid matching day columns */
            .week-untimed-container {
                display: none;
                background: #0d0d0d;
                border: 1px solid #1a1a1a;
                border-radius: 10px;
                padding: 16px;
                margin-bottom: 12px;
            }

            .week-untimed-container.has-tasks {
                display: block;
            }

            .week-untimed-header {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 12px;
                padding-bottom: 10px;
                border-bottom: 1px solid #1a1a1a;
            }

            .week-untimed-title {
                font-size: 14px;
                font-weight: 600;
                color: #a3a3a3;
            }

            .week-untimed-count {
                font-size: 12px;
                font-weight: 600;
                color: #525252;
                background: #1a1a1a;
                padding: 3px 10px;
                border-radius: 12px;
            }

            .week-untimed-days {
                display: grid;
                grid-template-columns: repeat(7, 1fr);
                gap: 12px;
            }

            .week-untimed-day {
                display: flex;
                flex-direction: column;
                gap: 6px;
                min-width: 0;
            }

            .week-untimed-day.empty {
                display: flex;
                opacity: 0.3;
            }

            .week-untimed-day.today {
                background: rgba(59, 130, 246, 0.05);
                border-radius: 6px;
                padding: 6px;
                margin: -6px;
            }

            .week-untimed-day-header {
                font-size: 11px;
                font-weight: 600;
                color: #525252;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                margin-bottom: 4px;
                text-align: center;
            }

            .week-untimed-day.today .week-untimed-day-header {
                color: #3b82f6;
            }

            .week-untimed-day-count {
                color: #404040;
                font-weight: 400;
            }

            .week-untimed-item {
                padding: 8px 10px;
                font-size: 13px;
                background: #141414;
                border-radius: 6px;
                border-left: 3px solid #3b82f6;
            }

            .week-untimed-item:hover {
                background: #1a1a1a;
            }
        }

        /* Month View - Optimized for fast switching */
        .month-container {
            display: none;
            content-visibility: auto;
        }

        .month-container.active {
            display: block;
        }

        /* Mobile Month List View - Compact */
        .month-list {
            display: flex;
            flex-direction: column;
            gap: 0;
            /* Optimize scroll performance */
            -webkit-overflow-scrolling: touch;
        }

        /* Month Header Separator */
        .month-header-separator {
            padding: 1rem 0.75rem 0.5rem;
            text-align: center;
            scroll-margin-top: 12rem;
        }

        .month-header-separator:first-child {
            padding-top: 0.5rem;
        }

        .month-header-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .month-header-separator.current .month-header-title {
            color: #3b82f6;
        }

        /* Month Block Container */
        .month-block {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 0.5rem;
            /* Optimize rendering during scroll */
            content-visibility: auto;
            contain-intrinsic-size: auto 400px;
        }

        /* Week Separator */
        .week-separator {
            height: 1px;
            background: #262626;
            margin: 0.25rem 0.75rem;
        }

        /* Compact date section with tasks */
        .month-date-section {
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
            scroll-margin-top: 10rem;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .month-date-section:last-child {
            border-bottom: none;
        }

        .month-date-section.today {
            background: rgba(59, 130, 246, 0.05);
        }

        /* Hover effect for all date sections */
        @media (hover: hover) {
            .month-date-section:hover {
                background: #0e0e0e;
            }

            .month-date-section:hover .month-date-header {
                background: #121212;
            }

            .month-date-section.today:hover {
                background: rgba(59, 130, 246, 0.08);
            }

            .month-date-section.today:hover .month-date-header {
                background: rgba(59, 130, 246, 0.12);
            }
        }

        .month-date-section:active {
            background: #111111;
        }

        .month-date-section.today:active {
            background: rgba(59, 130, 246, 0.1);
        }

        /* Add button indicator */
        .month-add-indicator {
            font-size: 0.9rem;
            color: #333333;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        @media (hover: hover) {
            .month-date-section:hover .month-add-indicator {
                opacity: 1;
            }
        }

        /* Compact header */
        .month-date-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: #0f0f0f;
        }

        .month-date-section.today .month-date-header {
            background: rgba(59, 130, 246, 0.1);
        }

        .month-date-title {
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .month-date-num {
            font-size: 0.9rem;
            font-weight: 600;
            color: #a3a3a3;
            min-width: 1.5rem;
            text-align: right;
            display: inline-block;
        }

        .month-date-section.today .month-date-num {
            color: #3b82f6;
        }

        .month-date-day {
            font-size: 0.7rem;
            font-weight: 500;
            color: #525252;
            text-transform: uppercase;
        }

        .month-date-section.today .month-date-day {
            color: #3b82f6;
        }

        .month-date-badge {
            font-size: 0.55rem;
            font-weight: 600;
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
            padding: 0.15rem 0.375rem;
            border-radius: 3px;
            display: none;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .month-date-section.today .month-date-badge {
            display: block;
        }

        /* Empty date - single compact line */
        .month-date-section.empty-section .month-date-header {
            background: transparent;
        }

        .month-date-section.empty-section .month-date-num {
            color: #404040;
        }

        .month-date-section.empty-section .month-date-day {
            color: #333333;
        }

        .month-empty-label {
            font-size: 0.65rem;
            color: #333333;
            margin-left: auto;
        }

        @media (hover: hover) {
            .month-date-section.empty-section:hover .month-empty-label {
                color: #525252;
            }
        }

        /* Compact task container */
        .month-date-tasks {
            padding: 0.375rem 0.5rem 0.5rem;
        }

        .month-date-tasks .day-tasks {
            gap: 0.25rem;
        }

        /* Compact task items in month view */
        .month-date-tasks .task-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.625rem;
            gap: 0.625rem;
            border-radius: 6px;
            animation: none;
        }

        .month-date-tasks .task-checkbox {
            width: 18px;
            height: 18px;
            border-width: 1.5px;
            border-radius: 4px;
            flex-shrink: 0;
            margin: 0;
        }

        .month-date-tasks .task-checkbox.checked::after {
            width: 9px;
            height: 5px;
            border-width: 1.5px;
        }

        .month-date-tasks .task-content {
            flex: 1;
            min-width: 0;
        }

        .month-date-tasks .task-name {
            font-size: 0.85rem;
            line-height: 1.3;
            text-align: left;
        }

        .month-date-tasks .task-badge {
            display: none;
        }

        .month-date-tasks .delete-button {
            width: 24px;
            height: 24px;
            font-size: 0.9rem;
            flex-shrink: 0;
            margin: 0;
        }

        /* Hide add button in compact view (use FAB instead) */
        .month-date-add {
            display: none;
        }

        /* Task count badge for sections with tasks */
        .month-task-count {
            font-size: 0.6rem;
            color: #525252;
            background: #1a1a1a;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            margin-left: auto;
        }

        /* Desktop Month Grid View */
        .month-grid {
            display: none;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #1a1a1a;
        }

        .month-weekday-header {
            background: #0f0f0f;
            padding: 0.5rem;
            text-align: center;
            font-size: 0.65rem;
            font-weight: 500;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .month-day {
            background: #0a0a0a;
            min-height: 90px;
            padding: 0.375rem;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        @media (hover: hover) {
            .month-day:not(.empty):hover {
                background: #111111;
            }
        }

        .month-day.empty {
            background: #050505;
            cursor: default;
        }

        .month-day.today {
            background: #111118;
            border: 1px solid #3b82f6;
        }

        .month-day-number {
            font-size: 0.75rem;
            color: #525252;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .month-day.today .month-day-number {
            color: #3b82f6;
            font-weight: 600;
        }

        .month-day.other-month .month-day-number {
            color: #333333;
        }

        /* Desktop Grid Task Items */
        .month-task-preview {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.3rem;
            background: #141414;
            border-radius: 4px;
            margin-bottom: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            position: relative;
        }

        .month-task-preview:hover {
            background: #1a1a1a;
        }

        .month-task-preview:active {
            transform: scale(0.98);
        }

        .month-task-preview.completed {
            opacity: 0.6;
        }

        .month-task-preview.removing {
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .month-task-checkbox {
            width: 12px;
            height: 12px;
            border: 1.5px solid #404040;
            border-radius: 2px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
        }

        /* Larger touch target for month view checkboxes */
        .month-task-checkbox::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            border-radius: 50%;
        }

        @media (hover: hover) {
            .month-task-checkbox:hover {
                border-color: #525252;
            }
            .month-task-checkbox.checked:hover {
                background: #2563eb;
                border-color: #2563eb;
            }
        }

        .month-task-checkbox:active {
            transform: scale(0.85);
        }

        .month-task-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .month-task-checkbox.checked::after {
            content: '';
            width: 6px;
            height: 3px;
            border: 1.5px solid #ffffff;
            border-top: none;
            border-right: none;
            transform: rotate(-45deg) translateY(-0.5px);
        }

        .month-task-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #404040;
            flex-shrink: 0;
            display: none;
        }

        .month-task-preview.completed .month-task-dot {
            background: #3b82f6;
        }

        .month-task-text {
            font-size: 0.6rem;
            color: #a3a3a3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .month-task-preview.completed .month-task-text {
            color: #525252;
        }

        .month-task-delete {
            width: 14px;
            height: 14px;
            background: transparent;
            border: none;
            color: #404040;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;  /* Mobile: always visible */
            transition: all 0.2s ease;
            padding: 0;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        /* Desktop: Show on hover */
        @media (hover: hover) {
            .month-task-delete {
                opacity: 0;
            }

            .month-task-preview:hover .month-task-delete {
                opacity: 1;
            }

            .month-task-delete:hover {
                color: #ef4444;
                background: rgba(239, 68, 68, 0.1);
            }
        }

        .month-more-tasks {
            font-size: 0.55rem;
            color: #3b82f6;
            padding: 0.15rem 0.3rem;
            text-align: center;
            cursor: pointer;
        }

        .month-more-tasks:hover {
            text-decoration: underline;
        }

        /* Task Indicators (fallback/dots) */
        .task-indicators {
            display: flex;
            gap: 3px;
            margin-top: 4px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 100%;
        }

        .task-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #404040;
        }

        .task-dot.completed {
            background: #3b82f6;
        }

        .task-count {
            font-size: 0.6rem;
            color: #525252;
            margin-top: 2px;
        }

        /* Responsive: Show grid on desktop, list on mobile */
        @media (max-width: 599px) {
            .month-list {
                display: flex;
            }
            .month-grid {
                display: none !important;
            }
        }

        @media (min-width: 600px) {
            .month-list {
                display: none;
            }
            .month-grid {
                display: grid !important;
            }
        }

        /* Desktop: 2-column month list layout option */
        @media (min-width: 800px) {
            .month-grid {
                gap: 3px;
            }

            .month-day {
                min-height: 100px;
            }

            .month-task-preview {
                padding: 0.25rem 0.4rem;
            }

            .month-task-text {
                font-size: 0.65rem;
            }
        }

        /* Task Items */
        .task-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: #141414;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1), border-color 0.2s ease;
            position: relative;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Animation only for newly added tasks */
        .task-item.new-task {
            animation: taskSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-item.completed {
            background: #181818;
        }

        @keyframes taskSlideIn {
            0% {
                opacity: 0;
                transform: translateY(-12px);
            }
            100% {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (hover: hover) {
            .task-item:hover {
                border-color: #262626;
            }
        }

        .task-item:active {
            background: #1a1a1a;
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            border: 1.5px solid #404040;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
            cursor: pointer;
            position: relative;
        }

        /* Larger touch target for mobile (44x44px minimum) */
        .task-checkbox::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 44px;
            height: 44px;
            border-radius: 50%;
        }

        @media (hover: hover) {
            .task-checkbox:hover {
                border-color: #525252;
            }
            .task-checkbox.checked:hover {
                background: #2563eb;
                border-color: #2563eb;
            }
        }

        .task-checkbox:active {
            transform: scale(0.9);
        }

        .task-checkbox.checked {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .task-checkbox.checked::after {
            content: '';
            width: 10px;
            height: 6px;
            border: 2px solid #ffffff;
            border-top: none;
            border-right: none;
            transform: rotate(-45deg) translateY(-1px);
        }

        /* Enhanced Visual Feedback - Completing Animation */
        .task-checkbox.completing {
            animation: checkboxPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        .task-checkbox.completing::before {
            animation: checkboxGlow 0.5s ease-out forwards;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.4) 0%, transparent 70%);
        }

        .task-item.completing {
            animation: taskPulse 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes checkboxPop {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes checkboxGlow {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            30% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }

        @keyframes taskPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.02);
            }
            100% {
                transform: scale(1);
            }
        }

        .task-content {
            flex: 1;
            min-width: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .task-name {
            font-size: 0.95rem;
            color: #d4d4d4;
            transition: all 0.2s ease;
            word-break: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            display: block;
        }

        .task-name.completed {
            color: #525252;
            opacity: 0.6;
        }

        .task-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.65rem;
            color: #525252;
            margin-top: 0.25rem;
        }

        .task-badge svg {
            width: 10px;
            height: 10px;
        }

        .delete-button {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            color: #404040;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        /* Mobile: Always show delete button */
        .delete-button {
            opacity: 0.4;
        }

        /* Desktop: Show on hover */
        @media (hover: hover) {
            .delete-button {
                opacity: 0.3;
            }

            .task-item:hover .delete-button {
                opacity: 1;
            }

            .delete-button:hover {
                color: #ef4444;
                background: rgba(239, 68, 68, 0.1);
            }
        }

        /* Empty State */
        .empty-day {
            text-align: center;
            padding: 2rem;
            color: #333333;
            font-size: 0.9rem;
        }

        /* XP Popup Animation - Enhanced */
        .xp-popup {
            position: absolute;
            left: 10px;
            top: -8px;
            font-size: 0.8rem;
            font-weight: 700;
            pointer-events: none;
            animation: xpFloatEnhanced 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            white-space: nowrap;
            text-shadow: 0 0 10px currentColor;
            z-index: 10;
        }

        .xp-popup.gain {
            color: #3b82f6;
        }

        .xp-popup.lose {
            color: #ef4444;
        }

        @keyframes xpFloatEnhanced {
            0% {
                opacity: 0;
                transform: translateY(0) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(-10px) scale(1.2);
            }
            40% {
                transform: translateY(-18px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-35px) scale(0.8);
            }
        }

        /* Level Up Toast */
        .level-up-toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%);
            border: 1px solid #333;
            border-radius: 16px;
            padding: 16px 28px;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .level-up-toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .level-up-toast-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .level-up-toast-emoji {
            font-size: 1.5rem;
        }

        .level-up-toast-text {
            font-size: 1rem;
            font-weight: 600;
            color: #ffffff;
        }

        .level-up-toast-level {
            color: #fbbf24;
        }

        /* Undo Toast */
        .undo-toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 6px 12px;
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .undo-toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        .undo-toast.hidden-for-celebration {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        .undo-toast-message {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
        }

        .undo-toast-btn {
            background: transparent;
            border: none;
            color: #3b82f6;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            padding: 0;
            margin-left: 2px;
        }

        .undo-toast-btn:hover {
            color: #60a5fa;
        }

        /* FAB */
        .fab {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            width: 56px;
            height: 56px;
            background: #3b82f6;
            border: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 1.75rem;
            font-weight: 300;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        @media (hover: hover) {
            .fab:hover {
                transform: rotate(90deg);
                box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5);
            }
        }

        .fab:active {
            transform: scale(0.95);
        }

        .fab.open {
            transform: rotate(45deg);
        }

        @media (hover: hover) {
            .fab.open:hover {
                transform: rotate(135deg);
            }
        }

        /* Modal Overlay */
        .modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal-overlay.active {
            display: flex;
        }

        /* Prevent body scroll when modal is open */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Task Creation Modal */
        .task-modal {
            position: relative;
            background: #141414;
            border: 1px solid #262626;
            border-radius: 16px;
            width: 95vw;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
            animation: modalSlide 0.2s ease;
            box-sizing: border-box;
            margin: auto;
        }

        /* Responsive modal widths */
        @media (min-width: 600px) {
            .task-modal {
                width: 500px;
                max-width: 500px;
            }
        }

        @media (min-width: 900px) {
            .task-modal {
                width: 600px;
                max-width: 600px;
            }
        }

        /* Small mobile screens */
        @media (max-width: 400px) {
            .task-modal {
                width: 100%;
                max-width: none;
                border-radius: 12px;
            }

            .modal-body {
                padding: 1rem;
            }

            .modal-header {
                padding: 0.875rem 1rem;
            }

            .modal-footer {
                padding: 0.875rem 1rem;
            }

            .modal-input,
            .modal-select,
            .modal-date-input,
            .modal-time-input,
            .modal-duration-select {
                padding: 0.75rem;
                font-size: 16px; /* Prevents iOS zoom */
            }

            .modal-day-toggle {
                padding: 0.5rem 0.25rem;
                font-size: 0.7rem;
                min-width: 38px;
            }

            /* Stack time/duration vertically on very small screens */
            .time-duration-row {
                flex-direction: column;
                gap: 10px;
            }

            .duration-field {
                width: 100%;
                max-width: 100%;
            }
        }

        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #262626;
        }

        .modal-header span {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e5e5;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            color: #737373;
            font-size: 1.25rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (hover: hover) {
            .modal-close:hover {
                background: #262626;
                color: #e5e5e5;
            }
        }

        .modal-body {
            padding: 1.25rem;
            width: 100%;
            overflow-x: hidden;
        }

        .modal-field {
            margin-bottom: 20px;
            width: 100%;
        }

        .modal-field:last-child {
            margin-bottom: 0;
        }

        .modal-label {
            display: block;
            width: 100%;
            text-align: left;
            font-size: 0.8rem;
            font-weight: 500;
            color: #737373;
            margin-bottom: 8px;
        }

        .modal-input {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            transition: all 0.2s ease;
            box-sizing: border-box;
        }

        .modal-input::placeholder {
            color: #525252;
        }

        .modal-input:focus {
            border-color: #3b82f6;
            background: #111111;
        }

        .modal-select {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            padding-right: 2.5rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            box-sizing: border-box;
        }

        .modal-select:focus {
            border-color: #3b82f6;
        }

        .modal-select option {
            background: #141414;
            color: #e5e5e5;
        }

        .modal-date-input {
            width: 100%;
            max-width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color-scheme: dark;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .modal-date-input:focus {
            border-color: #3b82f6;
        }

        /* Day Picker in Modal */
        .modal-day-picker {
            display: none;
            gap: 6px;
            flex-wrap: wrap;
            width: 100%;
        }

        .modal-day-picker.active {
            display: flex;
        }

        .modal-day-toggle {
            flex: 1;
            min-width: 0;
            padding: 0.625rem 0.125rem;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            color: #525252;
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        @media (hover: hover) {
            .modal-day-toggle:hover {
                border-color: #404040;
                color: #737373;
            }
        }

        .modal-day-toggle.selected {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
        }

        /* Every N Days Input */
        .every-n-days-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            flex-wrap: wrap;
        }

        .modal-number-input {
            width: 80px;
            flex-shrink: 0;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            transition: all 0.2s ease;
            text-align: center;
            -moz-appearance: textfield;
        }

        .modal-number-input::-webkit-outer-spin-button,
        .modal-number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .modal-number-input:focus {
            border-color: #3b82f6;
            background: #111111;
        }

        .every-n-days-label {
            color: #737373;
            font-size: 0.95rem;
        }

        /* Monthly Day Select */
        .monthly-hint {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #525252;
        }

        /* Time Toggle and Input */
        .time-toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #262626;
            transition: 0.2s;
            border-radius: 24px;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: #666;
            transition: 0.2s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #3b82f6;
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(20px);
            background-color: #fff;
        }

        .time-input-wrapper {
            margin-top: 0.75rem;
            width: 100%;
        }

        .modal-time-input {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color-scheme: dark;
            box-sizing: border-box;
        }

        .modal-time-input:focus {
            border-color: #3b82f6;
        }

        .time-duration-row {
            display: flex;
            gap: 12px;
            width: 100%;
        }

        .time-field {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }

        .duration-field {
            flex: 0 0 auto;
            width: 120px;
            max-width: 120px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .time-field-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-duration-select {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            box-sizing: border-box;
        }

        .modal-duration-select:focus {
            border-color: #3b82f6;
        }

        /* Task Time Display */
        .task-time {
            font-size: 0.8rem;
            color: #666;
            margin-right: 6px;
            font-variant-numeric: tabular-nums;
            flex-shrink: 0;
        }

        /* Time divider in Plan view */
        .time-section-divider {
            height: 1px;
            background: #262626;
            margin: 8px 0;
        }

        .modal-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid #262626;
        }

        .modal-submit {
            width: 100%;
            padding: 0.875rem;
            background: #3b82f6;
            border: none;
            border-radius: 8px;
            color: #ffffff;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        @media (hover: hover) {
            .modal-submit:hover {
                background: #2563eb;
            }
        }

        /* Notes Textarea in Modal */
        .modal-textarea {
            width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            transition: all 0.2s ease;
            resize: vertical;
            min-height: 100px;
            max-height: 200px;
            font-family: inherit;
            line-height: 1.5;
            box-sizing: border-box;
        }

        .modal-textarea::placeholder {
            color: #525252;
        }

        .modal-textarea:focus {
            border-color: #3b82f6;
            background: #111111;
        }

        .notes-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
            font-size: 0.75rem;
            color: #525252;
        }

        .notes-hint {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 1rem;
        }

        .notes-char-count {
            text-align: right;
            flex-shrink: 0;
        }

        .notes-char-count.near-limit {
            color: #f59e0b;
        }

        .notes-char-count.at-limit {
            color: #ef4444;
        }

        /* All task names are clickable for notes */
        .task-name {
            cursor: pointer;
            pointer-events: auto;
        }

        .month-task-text {
            cursor: pointer;
            pointer-events: auto;
        }

        /* ============================================
           Plan View - Weekly Planning Interface
           ============================================ */

        .plan-container {
            display: none;
            content-visibility: auto;
        }

        .plan-container.active {
            display: block;
        }

        .plan-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: #0a0a0a;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            flex-shrink: 0;
        }

        .plan-nav-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #a3a3a3;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
            min-height: 44px;
        }

        @media (hover: hover) {
            .plan-nav-btn:hover {
                background: rgba(255, 255, 255, 0.05);
                color: #e5e5e5;
                border-color: rgba(255, 255, 255, 0.25);
            }
        }

        .plan-nav-btn:active {
            transform: scale(0.97);
        }

        .plan-week-title {
            font-size: 1rem;
            font-weight: 600;
            color: #fafafa;
            text-align: center;
            letter-spacing: -0.01em;
        }

        .plan-title-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .plan-help-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent;
            color: #737373;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .plan-help-btn:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: #a3a3a3;
        }

        /* Plan Help Overlay */
        .plan-help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .plan-help-overlay.active {
            display: flex;
        }

        .plan-help-content {
            text-align: center;
        }

        .plan-help-tip {
            font-size: 1.125rem;
            font-weight: 500;
            color: #fafafa;
            margin-bottom: 8px;
        }

        .plan-help-tip:last-of-type {
            margin-bottom: 20px;
        }

        .plan-help-dismiss {
            font-size: 0.8125rem;
            color: #737373;
        }

        .plan-week-stats {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            flex-shrink: 0;
        }

        .plan-stats-text {
            font-size: 0.8125rem;
            color: #737373;
        }

        .plan-days {
            padding: 0 0 100px 0;
        }

        .plan-day-section {
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .plan-day-section:last-child {
            border-bottom: none;
        }

        .plan-day-header {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            background: #0f0f0f;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .plan-day-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .plan-day-name {
            font-size: 0.9375rem;
            font-weight: 600;
            color: #e5e5e5;
        }

        .plan-day-date {
            font-size: 0.8125rem;
            color: #525252;
        }

        .plan-day-section.is-today .plan-day-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.04) 0%, rgba(255, 255, 255, 0.02) 100%);
        }

        .plan-day-section.is-today .plan-day-name {
            color: #ffffff;
        }

        .plan-today-badge {
            font-size: 0.6875rem;
            font-weight: 500;
            color: #0a0a0a;
            background: #fafafa;
            padding: 2px 8px;
            border-radius: 10px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .plan-day-count {
            font-size: 0.75rem;
            color: #525252;
            background: rgba(255, 255, 255, 0.05);
            padding: 4px 10px;
            border-radius: 12px;
        }

        .plan-day-tasks {
            padding: 0 20px;
        }

        /* Plan view task items - consistent with other views */
        .plan-day-tasks .task-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            margin-bottom: 6px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.02);
            position: relative;
        }

        .plan-day-tasks .task-item:last-child {
            margin-bottom: 12px;
        }

        .plan-day-tasks .task-item.completed {
            background: rgba(255, 255, 255, 0.01);
        }

        .plan-day-tasks .task-checkbox {
            width: 18px;
            height: 18px;
            min-width: 18px;
            min-height: 18px;
            border-width: 2px;
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .plan-day-tasks .task-checkbox.checked::after {
            width: 8px;
            height: 5px;
            border-width: 2px;
            transform: rotate(-45deg);
            position: relative;
            left: 0;
            top: -1px;
        }

        .plan-day-tasks .task-name {
            font-size: 0.9375rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            padding: 2px 6px;
            margin: -2px -6px;
            border-radius: 4px;
        }

        /* Desktop: hover background highlight */
        @media (hover: hover) {
            .plan-day-tasks .task-name:hover {
                background-color: rgba(255, 255, 255, 0.05);
            }
        }

        /* Long-press visual feedback */
        .plan-day-tasks .task-name.pressing {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .plan-day-tasks .category-indicator {
            width: 6px;
            height: 6px;
        }

        .plan-day-tasks .delete-button {
            width: 28px;
            height: 28px;
            font-size: 1.1rem;
            flex-shrink: 0;
            margin: 0;
            margin-left: auto;
            opacity: 0;
            transition: opacity 0.15s ease, color 0.15s ease, background 0.15s ease;
        }

        /* Desktop: show delete on hover */
        @media (hover: hover) {
            .plan-day-tasks .task-item:hover .delete-button {
                opacity: 1;
            }
        }

        /* Mobile: always show delete button */
        @media (max-width: 768px) {
            .plan-day-tasks .delete-button {
                opacity: 0.6;
            }
        }

        .plan-empty-day {
            padding: 16px 20px;
            color: #404040;
            font-size: 0.875rem;
            font-style: italic;
        }

        /* Plan view inline task input */
        .plan-inline-input-container {
            padding: 0 20px;
            margin-top: 10px;
            margin-bottom: 8px;
        }

        .plan-inline-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 0.9375rem;
            color: #e5e5e5;
            outline: none;
            transition: all 0.15s ease;
            font-family: inherit;
            box-sizing: border-box;
        }

        .plan-inline-input::placeholder {
            color: #404040;
        }

        .plan-inline-input:focus {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .plan-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .plan-input-wrapper .plan-inline-input {
            padding-right: 44px;
        }

        .plan-gear-btn {
            position: absolute;
            right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: #525252;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .plan-gear-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #a3a3a3;
        }

        .plan-gear-btn:active {
            transform: scale(0.95);
        }

        .plan-gear-btn svg {
            width: 18px;
            height: 18px;
        }

        /* New task animation */
        .plan-day-tasks .task-item.new-task {
            animation: planTaskSlideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes planTaskSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Mobile optimization for Plan view */
        @media (max-width: 480px) {
            .plan-header {
                padding: 12px 16px;
            }

            .plan-nav-btn {
                padding: 8px 12px;
                font-size: 0.8125rem;
            }

            .plan-week-title {
                font-size: 0.875rem;
            }

            .plan-week-stats {
                padding: 10px 16px;
            }

            .plan-day-header {
                padding: 12px 16px;
            }

            .plan-inline-input-container {
                padding: 0 16px;
            }

            .plan-inline-input {
                font-size: 16px; /* Prevents iOS zoom on focus */
                padding: 14px 16px;
                padding-right: 48px; /* Space for gear button */
                min-height: 48px; /* Easy tap target */
            }

            .plan-gear-btn {
                width: 36px;
                height: 36px;
                right: 6px;
            }

            .plan-day-tasks {
                padding: 0 16px;
            }

            .plan-day-tasks .task-item {
                padding: 10px 14px;
            }
        }

        /* Desktop optimization for Plan view */
        @media (min-width: 768px) {
            .plan-header {
                padding: 20px 24px;
            }

            .plan-week-title {
                font-size: 1.125rem;
            }

            .plan-day-header {
                padding: 16px 24px;
            }

            .plan-inline-input-container {
                padding: 0 24px;
            }

            .plan-day-tasks {
                padding: 0 24px;
            }

            .plan-day-section {
                max-width: 800px;
            }

            .plan-days {
                padding: 0 24px 100px;
            }
        }

        /* ============================================
           Notes Modal - Ultra Modern Design
           Inspired by Linear, Notion, Arc, Apple
           ============================================ */

        #notesModal {
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        #notesModal.active {
            animation: notesOverlayIn 0.2s ease-out;
        }

        @keyframes notesOverlayIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .notes-modal {
            position: relative;
            background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
            border-radius: 24px;
            width: calc(100% - 2rem);
            max-width: 520px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            animation: notesModalIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-sizing: border-box;
            margin: 0 1rem;
            box-shadow:
                0 0 0 0.5px rgba(255, 255, 255, 0.1),
                0 0 80px rgba(255, 255, 255, 0.02),
                0 8px 16px rgba(0, 0, 0, 0.4),
                0 20px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.04);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @keyframes notesModalIn {
            from {
                opacity: 0;
                transform: scale(0.96) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .notes-modal-header {
            padding: 24px 28px 20px;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
        }

        .notes-modal-title {
            margin: 0;
            font-size: 22px;
            font-weight: 600;
            color: #ffffff;
            line-height: 1.3;
            word-break: break-word;
            letter-spacing: -0.02em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
        }

        .notes-modal-close {
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            opacity: 0.4;
            margin-top: 2px;
        }

        .notes-modal-close::before,
        .notes-modal-close::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 1.5px;
            background: #ffffff;
            border-radius: 1px;
        }

        .notes-modal-close::before {
            transform: rotate(45deg);
        }

        .notes-modal-close::after {
            transform: rotate(-45deg);
        }

        @media (hover: hover) {
            .notes-modal-close:hover {
                opacity: 0.7;
                background: rgba(255, 255, 255, 0.08);
            }
        }

        .notes-modal-close:active {
            transform: scale(0.9);
            opacity: 0.5;
        }

        .notes-modal-divider {
            height: 1px;
            margin: 0 28px;
            background: linear-gradient(90deg,
                rgba(255, 255, 255, 0.15) 0%,
                rgba(255, 255, 255, 0.06) 50%,
                transparent 100%);
        }

        .notes-modal-body {
            padding: 20px 28px 0;
            overflow-y: auto;
            flex: 1;
        }

        .notes-modal-textarea {
            width: 100%;
            background: #151515;
            border: 1px solid transparent;
            border-radius: 12px;
            padding: 16px 18px;
            font-size: 15px;
            color: #e5e5e5;
            outline: none;
            transition: all 0.2s ease;
            resize: none;
            min-height: 140px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.7;
            box-sizing: border-box;
        }

        .notes-modal-textarea::placeholder {
            color: #404040;
        }

        .notes-modal-textarea:focus {
            border-color: rgba(255, 255, 255, 0.3);
            background: #181818;
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.05);
        }

        .notes-modal-footer {
            padding: 20px 28px 28px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .notes-modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            letter-spacing: -0.01em;
        }

        .notes-modal-btn-secondary {
            background: transparent;
            color: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        @media (hover: hover) {
            .notes-modal-btn-secondary:hover {
                color: rgba(255, 255, 255, 0.8);
                border-color: rgba(255, 255, 255, 0.25);
                background: rgba(255, 255, 255, 0.05);
            }
        }

        .notes-modal-btn-secondary:active {
            transform: scale(0.97);
        }

        .notes-modal-btn-primary {
            background: #ffffff;
            color: #000000;
            padding: 12px 28px;
            font-weight: 600;
        }

        @media (hover: hover) {
            .notes-modal-btn-primary:hover {
                transform: translateY(-1px);
                box-shadow: 0 8px 24px rgba(255, 255, 255, 0.25);
            }
        }

        .notes-modal-btn-primary:active {
            transform: translateY(0) scale(0.98);
            box-shadow: none;
        }

        /* Mobile optimization */
        @media (max-width: 480px) {
            .notes-modal {
                max-width: none;
                margin: 0 12px;
                border-radius: 20px;
            }

            .notes-modal-header {
                padding: 20px 24px 16px;
            }

            .notes-modal-title {
                font-size: 20px;
            }

            .notes-modal-divider {
                margin: 0 24px;
            }

            .notes-modal-body {
                padding: 16px 24px 0;
            }

            .notes-modal-textarea {
                min-height: 120px;
                font-size: 16px;
                padding: 14px 16px;
            }

            .notes-modal-footer {
                padding: 16px 24px 24px;
            }

            .notes-modal-btn {
                padding: 14px 24px;
                font-size: 15px;
            }

            .notes-modal-btn-primary {
                padding: 14px 28px;
            }
        }

        /* Task Detail Modal (Read-only) */
        #taskDetailModal {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #taskDetailModal.active {
            display: flex;
        }

        .task-detail-modal {
            background: #0a0a0a;
            border: 1px solid #262626;
            border-radius: 16px;
            max-width: 400px;
            width: 100%;
            animation: taskDetailModalIn 0.25s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes taskDetailModalIn {
            from {
                opacity: 0;
                transform: scale(0.96) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .task-detail-header {
            display: flex;
            justify-content: flex-end;
            padding: 12px 16px 0;
        }

        .task-detail-close {
            background: none;
            border: none;
            color: #737373;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: color 0.15s ease;
        }

        .task-detail-close:hover {
            color: #fafafa;
        }

        .task-detail-body {
            padding: 0 24px 24px;
        }

        .task-detail-name {
            margin: 0 0 16px;
            font-size: 1.375rem;
            font-weight: 600;
            color: #fafafa;
            line-height: 1.3;
            word-break: break-word;
        }

        .task-detail-meta {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
        }

        .task-detail-category {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .task-detail-category-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9E9E9E;
        }

        .task-detail-category-name {
            font-size: 0.875rem;
            color: #a3a3a3;
        }

        .task-detail-type {
            font-size: 0.875rem;
            color: #737373;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        .task-detail-notes-section {
            border-top: 1px solid #262626;
            padding-top: 16px;
        }

        .task-detail-notes-label {
            font-size: 0.75rem;
            color: #737373;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .task-detail-notes {
            font-size: 0.9375rem;
            color: #d4d4d4;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .task-detail-notes.empty {
            color: #525252;
            font-style: italic;
        }

        .task-detail-footer {
            padding: 16px 24px 20px;
            border-top: 1px solid #262626;
        }

        .task-detail-edit-btn {
            width: 100%;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid #404040;
            border-radius: 8px;
            color: #fafafa;
            font-size: 0.9375rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .task-detail-edit-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #525252;
        }

        .task-detail-edit-btn:active {
            transform: scale(0.98);
        }

        @media (max-width: 480px) {
            .task-detail-modal {
                max-width: none;
                margin: 0;
                border-radius: 16px;
            }

            .task-detail-body {
                padding: 0 20px 20px;
            }

            .task-detail-footer {
                padding: 16px 20px 20px;
            }
        }

        .modal-submit:active {
            transform: scale(0.98);
        }

        /* Delete Modal */
        .modal {
            background: #141414;
            border: 1px solid #262626;
            border-radius: 12px;
            padding: 1.25rem;
            max-width: 300px;
            width: 90%;
            animation: modalSlide 0.15s ease;
        }

        .modal-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e5e5e5;
            margin-bottom: 0.375rem;
        }

        .modal-text {
            font-size: 0.8rem;
            color: #737373;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .modal-btn {
            padding: 0.625rem 0.875rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .modal-btn-primary {
            background: #1a1a1a;
            border-color: #262626;
            color: #ef4444;
        }

        @media (hover: hover) {
            .modal-btn-primary:hover {
                background: #262626;
            }
        }

        .modal-btn-secondary {
            background: #1a1a1a;
            border-color: #262626;
            color: #d4d4d4;
        }

        @media (hover: hover) {
            .modal-btn-secondary:hover {
                background: #262626;
            }
        }

        .modal-btn-cancel {
            background: transparent;
            color: #525252;
        }

        @media (hover: hover) {
            .modal-btn-cancel:hover {
                color: #737373;
            }
        }

        /* Week Navigation Bottom Bar (mobile only) */
        .week-nav-bar {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 28px;
            padding: 6px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            body[data-view="week"] .week-nav-bar {
                display: flex;
                gap: 8px;
            }
        }

        .week-nav-bar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            border-radius: 20px;
            color: #b0b0b0;
            font-size: 22px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s ease, color 0.15s ease, transform 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: manipulation;
        }

        .week-nav-bar-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
        }

        .week-nav-bar-btn:hover {
            color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
        }


        /* Bottom Sheet */
        .bottom-sheet-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 900;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .bottom-sheet-overlay.active {
            display: block;
            opacity: 1;
        }

        .bottom-sheet {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            background: #141414;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            z-index: 950;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
        }

        .bottom-sheet.open {
            transform: translateY(0);
        }

        .sheet-handle {
            width: 40px;
            height: 4px;
            background: #404040;
            border-radius: 2px;
            margin: 12px auto;
        }

        .sheet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.25rem 1rem;
            border-bottom: 1px solid #262626;
        }

        .sheet-date {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e5e5;
        }

        .sheet-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            color: #737373;
            font-size: 1.25rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (hover: hover) {
            .sheet-close:hover {
                background: #262626;
                color: #e5e5e5;
            }
        }

        .sheet-tasks {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.25rem;
            padding-bottom: 2rem;
        }

        .sheet-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.875rem;
            background: #0f0f0f;
            border: 1px dashed #262626;
            border-radius: 8px;
            color: #525252;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 0.75rem;
        }

        @media (hover: hover) {
            .sheet-add-btn:hover {
                border-color: #404040;
                color: #737373;
            }
        }

        /* Recurring Task Indicator */
        .recurring-indicator {
            font-size: 14px;
            color: #666;
            margin-right: 4px;
            flex-shrink: 0;
            cursor: help;
            position: relative;
            line-height: 1;
        }

        .recurring-indicator::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #262626;
            color: #e5e5e5;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
            z-index: 100;
            margin-bottom: 4px;
        }

        .recurring-indicator:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Category Indicator */
        .category-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Week grid smaller indicator */
        .week-grid-tasks .category-indicator {
            width: 5px;
            height: 5px;
        }

        /* Month grid indicator */
        .month-task-preview .category-indicator {
            width: 4px;
            height: 4px;
        }

        /* Smaller recurring indicator in compact views */
        .week-grid-tasks .recurring-indicator,
        .month-task-preview .recurring-indicator {
            font-size: 12px;
            margin-right: 3px;
        }

        /* Mobile tooltip positioning - align left to prevent cutoff */
        @media (max-width: 600px) {
            .recurring-indicator::after {
                left: 0;
                transform: translateX(0);
                max-width: 180px;
            }
        }

        /* Category Select in Modal */
        .modal-category-select {
            width: 100%;
            max-width: 100%;
            background: #0f0f0f;
            border: 1px solid #262626;
            border-radius: 8px;
            padding: 0.875rem 1rem;
            padding-right: 2rem;
            padding-left: 2.5rem;
            font-size: 16px; /* Prevents iOS zoom */
            color: #e5e5e5;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23737373' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
        }

        .modal-category-select:focus {
            border-color: #3b82f6;
        }

        .modal-category-select option {
            background: #141414;
            color: #e5e5e5;
        }

        .category-select-wrapper {
            position: relative;
            width: 100%;
        }

        .category-select-indicator {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
        }

        /* Stats View - Optimized for fast switching */
        .stats-container {
            display: none;
            content-visibility: auto;
        }

        .stats-container.active {
            display: block;
        }

        /* Quick Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        @media (min-width: 600px) {
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .stat-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            transition: border-color 0.2s ease;
        }

        @media (hover: hover) {
            .stat-card:hover {
                border-color: #333333;
            }
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #ffffff;
            line-height: 1.1;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #525252;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Weekly Summary Section */
        .stats-section {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1rem;
            overflow: hidden;
            box-sizing: border-box;
        }

        .stats-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .stats-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e5e5e5;
        }

        .stats-section-subtitle {
            font-size: 0.7rem;
            color: #525252;
        }

        /* Overall Progress Bar */
        .overall-progress {
            margin-bottom: 1.25rem;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #a3a3a3;
        }

        .progress-percent {
            font-size: 0.75rem;
            color: #525252;
        }

        .stats-progress-bar {
            height: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
        }

        .stats-progress-fill {
            height: 100%;
            background: #e5e5e5;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Category Breakdown */
        .category-breakdown {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
        }

        .category-breakdown-title {
            font-size: 0.75rem;
            font-weight: 500;
            color: #737373;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .category-stat {
            display: grid;
            grid-template-columns: 110px 1fr 40px;
            gap: 0.75rem;
            align-items: center;
            width: 100%;
        }

        .category-stat-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0;
        }

        .category-stat-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .category-stat-name {
            font-size: 0.8rem;
            color: #a3a3a3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .category-progress-wrapper {
            width: 100%;
            height: 8px;
            position: relative;
        }

        .category-progress-container {
            height: 100%;
            background: #1a1a1a;
            border-radius: 4px;
            overflow: hidden;
            box-sizing: border-box;
            position: absolute;
            left: 0;
            top: 0;
        }

        .category-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .category-stat-count {
            font-size: 0.75rem;
            color: #737373;
            white-space: nowrap;
            text-align: right;
        }

        /* Desktop: Wider category name */
        @media (min-width: 500px) {
            .category-stat {
                grid-template-columns: 140px 1fr 45px;
            }
        }

        /* Empty state for stats */
        .stats-empty {
            text-align: center;
            padding: 2rem 1rem;
            color: #525252;
            font-size: 0.85rem;
        }

        /* Time Allocation Chart */
        .time-allocation {
            margin-top: 1.5rem;
        }

        .time-allocation-summary {
            font-size: 0.8rem;
            color: #a3a3a3;
            margin-bottom: 1rem;
        }

        .time-allocation-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .time-allocation-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-category-name {
            flex-shrink: 0;
            min-width: 140px;
            color: #a3a3a3;
            font-size: 0.875rem;
        }

        .time-bar-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            min-width: 40px;
            /* flex-grow set inline per category for proportional sizing */
        }

        .time-bar-container {
            flex: 1;
            height: 16px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            /* background set inline with 30% opacity category color */
        }

        .time-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .time-label {
            flex-shrink: 0;
            white-space: nowrap;
            color: #e5e5e5;
            font-size: 0.875rem;
        }

        .time-allocation-empty {
            text-align: center;
            padding: 1.5rem 1rem;
            color: #525252;
            font-size: 0.85rem;
        }


        /* Hide date nav in stats view */
        body[data-view="stats"] .date-nav {
            display: none;
        }

        /* Hide FAB in stats view */
        body[data-view="stats"] .fab {
            display: none;
        }

        /* Achievements Section */
        .achievements-section {
            margin-top: 1rem;
        }

        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        @media (min-width: 500px) {
            .achievements-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (min-width: 700px) {
            .achievements-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        .achievement-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 0.75rem;
            transition: all 0.2s ease;
        }

        .achievement-card.unlocked {
            border-color: #505050;
            background: #111;
        }

        .achievement-card.locked {
            opacity: 1;
        }

        .achievement-header {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            margin-bottom: 0.25rem;
        }

        .achievement-check {
            color: #4CAF50;
            font-size: 0.75rem;
        }

        .achievement-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: #525252;
        }

        .achievement-card.unlocked .achievement-name {
            color: #e5e5e5;
        }

        .achievement-req {
            font-size: 0.65rem;
            color: #404040;
            margin-bottom: 0.375rem;
        }

        .achievement-card.unlocked .achievement-req {
            color: #737373;
        }

        .achievement-xp {
            font-size: 0.7rem;
            font-weight: 600;
            color: #404040;
        }

        .achievement-card.unlocked .achievement-xp {
            color: #FFD700;
        }

        .achievement-date {
            font-size: 0.6rem;
            color: #404040;
            margin-top: 0.25rem;
        }

        .achievement-progress {
            font-size: 0.7rem;
            color: #525252;
            padding: 0.5rem 0;
            border-top: 1px solid #1a1a1a;
            margin-top: 0.5rem;
        }

        .achievement-progress-bar {
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.375rem;
        }

        .achievement-progress-fill {
            height: 100%;
            background: #404040;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .card-progress {
            margin-top: 0.5rem;
        }

        .card-progress-text {
            font-size: 0.6rem;
            color: #525252;
            margin-bottom: 0.25rem;
        }

        .card-progress-bar {
            height: 3px;
            background: #1a1a1a;
            border-radius: 2px;
            overflow: hidden;
        }

        .card-progress-fill {
            height: 100%;
            background: #525252;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .achievements-reset-container {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid #1a1a1a;
            text-align: center;
        }

        .achievements-reset-btn {
            background: transparent;
            border: 1px solid #333;
            color: #525252;
            font-size: 0.7rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .achievements-reset-btn:hover {
            border-color: #525252;
            color: #737373;
        }

        /* Confirmation Modal */
        .confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2100;
            align-items: center;
            justify-content: center;
        }

        .confirm-overlay.active {
            display: flex;
        }

        .confirm-modal {
            background: #111;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 320px;
            width: 90%;
            text-align: center;
        }

        .confirm-title {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e5e5;
            margin-bottom: 0.75rem;
        }

        .confirm-message {
            font-size: 0.8rem;
            color: #737373;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        .confirm-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
        }

        .confirm-btn {
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .confirm-btn-cancel {
            background: transparent;
            border: 1px solid #333;
            color: #737373;
        }

        .confirm-btn-cancel:hover {
            border-color: #525252;
            color: #a5a5a5;
        }

        .confirm-btn-confirm {
            background: #b91c1c;
            border: none;
            color: #fff;
        }

        .confirm-btn-confirm:hover {
            background: #dc2626;
        }

        /* Celebration Modal */
        .celebration-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease;
        }

        .celebration-overlay.active {
            display: flex;
        }

        .celebration-card {
            background: #141414;
            border: 1px solid #333333;
            border-radius: 16px;
            padding: 2rem;
            text-align: center;
            max-width: 300px;
            width: 90%;
            animation: celebrationPop 0.3s ease;
        }

        @keyframes celebrationPop {
            0% {
                opacity: 0;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .celebration-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #737373;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }

        .celebration-name {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 0.375rem;
        }

        .celebration-req {
            font-size: 0.85rem;
            color: #737373;
            margin-bottom: 1rem;
        }

        .celebration-xp {
            font-size: 1.25rem;
            font-weight: 700;
            color: #FFD700;
        }

        /* Responsive */
        @media (min-width: 600px) {
            .container {
                max-width: 900px;
            }

            .sticky-header {
                padding: 1rem 1rem 0;
            }
        }
        /* ========== Auth Screen ========== */
        #auth-container {
            position: fixed;
            inset: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 1rem;
        }
        .auth-card {
            width: 100%;
            max-width: 400px;
            background: #111;
            border: 1px solid #222;
            border-radius: 16px;
            padding: 2.5rem 2rem;
            text-align: center;
        }
        .auth-card h1 {
            font-size: 1.6rem;
            font-weight: 600;
            color: #fff;
            letter-spacing: -0.02em;
            margin-bottom: 0.35rem;
        }
        .auth-card .auth-subtitle {
            font-size: 0.8rem;
            color: #555;
            margin-bottom: 2rem;
        }
        .auth-input {
            display: block;
            width: 100%;
            background: #0a0a0a;
            border: 1px solid #222;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            color: #fff;
            font-family: inherit;
            margin-bottom: 0.75rem;
            min-height: 44px;
            outline: none;
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            border-color: #444;
        }
        .auth-input::placeholder {
            color: #444;
        }
        .auth-submit {
            display: block;
            width: 100%;
            background: #fff;
            color: #0a0a0a;
            border: none;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            min-height: 44px;
            margin-top: 0.5rem;
            transition: opacity 0.15s;
        }
        .auth-submit:active {
            opacity: 0.7;
        }
        .auth-submit:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .auth-toggle {
            margin-top: 1.25rem;
            font-size: 0.78rem;
            color: #555;
            cursor: pointer;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .auth-toggle span {
            color: #fff;
            font-weight: 500;
            margin-left: 0.3rem;
        }
        #auth-error {
            display: none;
            background: rgba(255, 60, 60, 0.08);
            border: 1px solid rgba(255, 60, 60, 0.2);
            border-radius: 8px;
            padding: 0.6rem 0.8rem;
            margin-bottom: 0.75rem;
            font-size: 0.78rem;
            color: #ff4444;
            text-align: left;
        }
        /* Sign-out button in header */
        .header-top-row {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 0.25rem;
        }
        .header-top-row .app-title {
            margin-bottom: 0;
        }
        #sign-out-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: 1px solid #222;
            border-radius: 6px;
            color: #555;
            font-size: 0.65rem;
            font-family: inherit;
            padding: 0.3rem 0.55rem;
            cursor: pointer;
            transition: color 0.15s, border-color 0.15s;
            min-height: 28px;
            display: flex;
            align-items: center;
        }
        #sign-out-btn:active {
            color: #fff;
            border-color: #444;
        }
        @media (hover: hover) {
            #sign-out-btn:hover {
                color: #fff;
                border-color: #444;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
</head>
<body>
    <!-- Auth Screen -->
    <div id="auth-container">
        <div class="auth-card">
            <h1>Life Gamified</h1>
            <p class="auth-subtitle">Turn your daily habits into an adventure</p>
            <div id="auth-error"></div>
            <form id="auth-form" autocomplete="on">
                <input class="auth-input" type="email" id="auth-email" placeholder="Email" required autocomplete="email">
                <input class="auth-input" type="password" id="auth-password" placeholder="Password" required minlength="6" autocomplete="current-password">
                <button class="auth-submit" type="submit" id="auth-submit-btn">Sign In</button>
            </form>
            <div class="auth-toggle" id="auth-toggle">
                Don't have an account?<span>Sign up</span>
            </div>
        </div>
    </div>

    <!-- Notification / install banner (populated by JS) -->
    <div id="notif-banner"></div>

    <div class="container" id="app-container" style="display: none;">
        <div class="sticky-header">
            <header class="header">
                <div class="header-top-row">
                    <h1 class="app-title">Life Gamified</h1>
                    <button type="button" id="sign-out-btn">Sign Out</button>
                </div>
                <p class="app-subtitle">Turn your daily habits into an adventure</p>
                <div class="level-container">
                    <div class="level-info">
                        <span class="level-badge">Level <span id="currentLevel">1</span></span>
                        <span class="xp-text"><span id="currentXp">0</span> / <span id="xpToNext">100</span> XP</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                </div>
            </header>

            <div class="date-nav" id="dateNav">
                <div class="date-nav-center">
                    <button type="button" class="nav-arrow" id="prevDate">&#8592;</button>
                    <div class="date-display-container" id="dateDisplayContainer">
                        <div class="date-badge" id="dateBadge">
                            <span class="date-badge-month" id="dateBadgeMonth">JAN</span>
                            <span class="date-badge-day" id="dateBadgeDay">15</span>
                            <span class="date-badge-weekday" id="dateBadgeWeekday">Wednesday</span>
                        </div>
                    </div>
                    <button type="button" class="nav-arrow" id="nextDate">&#8594;</button>
                </div>
                <button type="button" class="today-btn" id="todayBtn">Today</button>
            </div>

            <div class="view-toggle-container">
                <div class="view-toggle">
                    <button type="button" class="view-btn" id="dayViewBtn">Day</button>
                    <button type="button" class="view-btn" id="weekViewBtn">Week</button>
                    <button type="button" class="view-btn" id="monthViewBtn">Month</button>
                    <button type="button" class="view-btn" id="planViewBtn">Plan</button>
                    <button type="button" class="view-btn" id="statsViewBtn">Stats</button>
                </div>
            </div>
        </div>

        <div class="main-content">
        <!-- Day View -->
        <div class="day-view-container view-container" id="dayViewContainer">
            <div class="day-timeline-container" id="dayTimelineContainer">
                <div class="timeline-untimed-section" id="timelineUntimedSection">
                    <div class="timeline-untimed-header">
                        Untimed Tasks
                        <span class="untimed-count-badge" id="untimedCountBadge">0</span>
                    </div>
                    <div class="timeline-untimed-tasks" id="timelineUntimedTasks"></div>
                </div>
                <div class="day-timeline" id="dayTimeline">
                    <!-- Hour rows and tasks rendered by JS -->
                </div>
            </div>
        </div>

        <!-- Week View -->
        <div class="week-view-container view-container" id="weekViewContainer">
            <!-- Untimed tasks section (above scroll container) -->
            <div class="week-untimed-container" id="weekUntimedContainer">
                <div class="week-untimed-header">
                    <span class="week-untimed-title">Untimed Tasks</span>
                    <span class="week-untimed-count" id="weekUntimedCount">0</span>
                </div>
                <div class="week-untimed-days" id="weekUntimedDays">
                    <!-- Day groups rendered by JS -->
                </div>
            </div>

            <!-- Main scroll container for sticky positioning -->
            <div class="week-scroll-container" id="weekScrollContainer">
                <!-- STICKY ROW: Day headers (Mon, Tue, etc.) - direct child of scroll container -->
                <div class="week-day-headers" id="weekDayHeaders">
                    <div class="week-header-corner"></div>
                    <!-- Day header cells rendered by JS -->
                </div>

                <!-- Timeline content wrapper -->
                <div class="week-timeline-content">
                    <!-- STICKY COLUMN: Hour markers - direct child for sticky left -->
                    <div class="week-hour-markers" id="weekHourMarkers">
                        <!-- Hour markers rendered by JS -->
                    </div>

                    <!-- 7 Day columns grid -->
                    <div class="week-days-grid" id="weekDaysGrid">
                        <!-- Day columns rendered by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Month View -->
        <div class="month-container view-container" id="monthContainer">
            <div class="month-list" id="monthList"></div>
            <div class="month-grid" id="monthGrid"></div>
        </div>

        <!-- Stats View -->
        <div class="stats-container view-container" id="statsContainer">
            <!-- Quick Stats Grid -->
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-value" id="statTotalCompleted">0</div>
                    <div class="stat-label">Tasks Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statStreak">0</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statCompletionRate">0%</div>
                    <div class="stat-label">Completion Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="statLevel">1</div>
                    <div class="stat-label">Level</div>
                </div>
            </div>

            <!-- Weekly Summary Section -->
            <div class="stats-section">
                <div class="stats-section-header">
                    <span class="stats-section-title">This Week</span>
                    <span class="stats-section-subtitle" id="weekDateRange">Jan 20 - Jan 26</span>
                </div>

                <!-- Overall Progress -->
                <div class="overall-progress">
                    <div class="progress-header">
                        <span class="progress-text" id="weekProgressText">0 of 0 tasks completed</span>
                        <span class="progress-percent" id="weekProgressPercent">0%</span>
                    </div>
                    <div class="stats-progress-bar">
                        <div class="stats-progress-fill" id="weekProgressFill" style="width: 0%;"></div>
                    </div>
                </div>

                <!-- Category Breakdown -->
                <div class="category-breakdown">
                    <div class="category-breakdown-title">By Category</div>
                    <div id="categoryBreakdown"></div>
                </div>

                <!-- Time Allocation -->
                <div class="time-allocation">
                    <div class="category-breakdown-title">Time Allocation This Week</div>
                    <div class="time-allocation-summary" id="timeAllocationSummary"></div>
                    <div class="time-allocation-bars" id="timeAllocationBars"></div>
                </div>
            </div>

            <!-- Achievements Section -->
            <div class="stats-section achievements-section">
                <div class="stats-section-header">
                    <span class="stats-section-title">Achievements</span>
                </div>

                <!-- Streak Achievements -->
                <div class="category-breakdown-title">Streak</div>
                <div class="achievements-grid" id="streakAchievements"></div>
                <div class="achievement-progress" id="streakProgress"></div>

                <!-- Completion Achievements -->
                <div class="category-breakdown-title" style="margin-top: 1rem;">Completion</div>
                <div class="achievements-grid" id="completionAchievements"></div>
                <div class="achievement-progress" id="completionProgress"></div>

                <!-- Reset Button (for testing) -->
                <div class="achievements-reset-container">
                    <button type="button" class="achievements-reset-btn" id="resetAchievementsBtn" onclick="showResetConfirmation()">Reset Achievements</button>
                </div>
            </div>
        </div>

        <!-- Plan View -->
        <div class="plan-container view-container" id="planContainer">
            <div class="plan-header">
                <button type="button" class="plan-nav-btn" id="planPrevWeek">← Prev</button>
                <div class="plan-title-wrapper">
                    <div class="plan-week-title" id="planWeekTitle">Week of Jan 27 - Feb 2</div>
                    <button type="button" class="plan-help-btn" id="planHelpBtn" aria-label="Help">?</button>
                </div>
                <button type="button" class="plan-nav-btn" id="planNextWeek">Next →</button>
            </div>
            <div class="plan-week-stats" id="planWeekStats">
                <span class="plan-stats-text">0 of 0 tasks completed</span>
            </div>
            <div class="plan-days" id="planDays">
                <!-- Day sections will be rendered here -->
            </div>
        </div>

        <!-- Plan Help Overlay -->
        <div class="plan-help-overlay" id="planHelpOverlay">
            <div class="plan-help-content">
                <div class="plan-help-tip">Tap to view details</div>
                <div class="plan-help-tip">Long press to edit</div>
                <div class="plan-help-dismiss">Tap anywhere to dismiss</div>
            </div>
        </div>
    </div>

    <!-- Celebration Modal -->
    <div class="celebration-overlay" id="celebrationOverlay">
        <div class="celebration-card">
            <div class="celebration-label">Achievement Unlocked!</div>
            <div class="celebration-name" id="celebrationName">Achievement</div>
            <div class="celebration-req" id="celebrationReq">Requirement</div>
            <div class="celebration-xp" id="celebrationXp">+100 XP</div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="confirm-overlay" id="confirmOverlay">
        <div class="confirm-modal">
            <div class="confirm-title">Reset Achievements?</div>
            <div class="confirm-message">This will lock all achievements and remove bonus XP. Your task completion progress will remain. This cannot be undone.</div>
            <div class="confirm-buttons">
                <button type="button" class="confirm-btn confirm-btn-cancel" id="confirmCancel" onclick="hideResetConfirmation()">Cancel</button>
                <button type="button" class="confirm-btn confirm-btn-confirm" id="confirmReset" onclick="resetAchievements()">Reset</button>
            </div>
        </div>
    </div>

    <!-- FAB -->
    <button type="button" class="fab" id="fabButton">+</button>

    <!-- Task Creation Modal -->
    <div class="modal-overlay" id="createTaskModal">
        <div class="task-modal">
            <div class="modal-header">
                <span id="modalTitleText">New Task</span>
                <button type="button" class="modal-close" id="modalCloseBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-field">
                    <label class="modal-label">Task Name</label>
                    <input type="text" class="modal-input" id="modalTaskInput" placeholder="What do you want to do?">
                </div>
                <div class="modal-field">
                    <label class="modal-label">Notes (optional)</label>
                    <textarea class="modal-textarea" id="modalNotesInput" placeholder="Add details, links, or reminders..." maxlength="500" rows="3"></textarea>
                    <div class="notes-meta">
                        <span class="notes-hint">Tip: Add links, bullet points, or context</span>
                        <span class="notes-char-count" id="notesCharCount">0/500</span>
                    </div>
                </div>
                <div class="modal-field">
                    <label class="modal-label">Category</label>
                    <div class="category-select-wrapper">
                        <div class="category-select-indicator" id="categoryIndicator" style="background: #9E9E9E;"></div>
                        <select class="modal-category-select" id="modalCategorySelect">
                            <option value="general">General</option>
                            <option value="health">Health & Fitness</option>
                            <option value="learning">Learning</option>
                            <option value="creative">Creative</option>
                            <option value="wellness">Wellness</option>
                            <option value="productivity">Productivity</option>
                            <option value="social">Social</option>
                        </select>
                    </div>
                </div>
                <div class="modal-field">
                    <label class="modal-label">Type</label>
                    <select class="modal-select" id="modalTypeSelect">
                        <option value="onetime">One-time</option>
                        <option value="daily">Daily</option>
                        <option value="every-n-days">Every N Days</option>
                        <option value="custom">Custom Days</option>
                        <option value="monthly">Monthly</option>
                    </select>
                </div>
                <div class="modal-field" id="modalDateField">
                    <label class="modal-label" id="modalDateLabel">Date</label>
                    <input type="date" class="modal-date-input" id="modalDateInput">
                </div>
                <div class="modal-field" id="modalEveryNDaysField" style="display: none;">
                    <label class="modal-label">Repeat every</label>
                    <div class="every-n-days-input-wrapper">
                        <input type="number" class="modal-number-input" id="modalEveryNDaysInput" min="2" max="30" value="2">
                        <span class="every-n-days-label">days</span>
                    </div>
                </div>
                <div class="modal-field" id="modalMonthlyField" style="display: none;">
                    <label class="modal-label">Day of month</label>
                    <select class="modal-select" id="modalMonthlyDaySelect">
                        <option value="1">1st</option>
                        <option value="2">2nd</option>
                        <option value="3">3rd</option>
                        <option value="4">4th</option>
                        <option value="5">5th</option>
                        <option value="6">6th</option>
                        <option value="7">7th</option>
                        <option value="8">8th</option>
                        <option value="9">9th</option>
                        <option value="10">10th</option>
                        <option value="11">11th</option>
                        <option value="12">12th</option>
                        <option value="13">13th</option>
                        <option value="14">14th</option>
                        <option value="15">15th</option>
                        <option value="16">16th</option>
                        <option value="17">17th</option>
                        <option value="18">18th</option>
                        <option value="19">19th</option>
                        <option value="20">20th</option>
                        <option value="21">21st</option>
                        <option value="22">22nd</option>
                        <option value="23">23rd</option>
                        <option value="24">24th</option>
                        <option value="25">25th</option>
                        <option value="26">26th</option>
                        <option value="27">27th</option>
                        <option value="28">28th</option>
                        <option value="29">29th</option>
                        <option value="30">30th</option>
                        <option value="31">31st</option>
                    </select>
                    <span class="monthly-hint">Task appears on this day each month</span>
                </div>
                <div class="modal-field" id="modalDayPickerField" style="display: none;">
                    <label class="modal-label">Select Days</label>
                    <div class="modal-day-picker active" id="modalDayPicker">
                        <button type="button" class="modal-day-toggle" data-day="0">Mon</button>
                        <button type="button" class="modal-day-toggle" data-day="1">Tue</button>
                        <button type="button" class="modal-day-toggle" data-day="2">Wed</button>
                        <button type="button" class="modal-day-toggle" data-day="3">Thu</button>
                        <button type="button" class="modal-day-toggle" data-day="4">Fri</button>
                        <button type="button" class="modal-day-toggle" data-day="5">Sat</button>
                        <button type="button" class="modal-day-toggle" data-day="6">Sun</button>
                    </div>
                </div>
                <div class="modal-field" id="modalTimeField">
                    <div class="time-toggle-row">
                        <label class="modal-label">Add time</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="modalTimeToggle">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="time-input-wrapper" id="timeInputWrapper" style="display: none;">
                        <div class="time-duration-row">
                            <div class="time-field">
                                <label class="time-field-label">Start time</label>
                                <input type="time" class="modal-time-input" id="modalTimeInput" value="09:00">
                            </div>
                            <div class="duration-field">
                                <label class="time-field-label">Duration</label>
                                <select class="modal-duration-select" id="modalDurationSelect">
                                    <option value="15">15 min</option>
                                    <option value="30" selected>30 min</option>
                                    <option value="45">45 min</option>
                                    <option value="60">1 hour</option>
                                    <option value="90">1.5 hours</option>
                                    <option value="120">2 hours</option>
                                    <option value="180">3 hours</option>
                                    <option value="240">4 hours</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="modal-submit" id="modalSubmitBtn">Add Task</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal-overlay" id="deleteModal">
        <div class="modal">
            <div class="modal-title" id="modalTitle">Delete Repeating Task</div>
            <div class="modal-text" id="modalText">This task repeats on multiple days. How would you like to delete it?</div>
            <div class="modal-buttons">
                <button type="button" class="modal-btn modal-btn-secondary" onclick="deleteThisDay()">Delete from this day only</button>
                <button type="button" class="modal-btn modal-btn-primary" onclick="deleteAllDays()">Delete from all days</button>
                <button type="button" class="modal-btn modal-btn-cancel" onclick="closeDeleteModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Week Navigation Bottom Bar (mobile only) -->
    <div class="week-nav-bar" id="weekNavBar">
        <button type="button" class="week-nav-bar-btn" id="weekNavPrev" aria-label="Previous week">←</button>
        <button type="button" class="week-nav-bar-btn" id="weekNavNext" aria-label="Next week">→</button>
    </div>

    <!-- Notes Modal -->
    <div class="modal-overlay" id="notesModal">
        <div class="notes-modal">
            <div class="notes-modal-header">
                <h2 class="notes-modal-title" id="notesModalTitle">Task Name</h2>
                <button type="button" class="notes-modal-close" id="notesModalClose" aria-label="Close"></button>
            </div>
            <div class="notes-modal-divider"></div>
            <div class="notes-modal-body">
                <textarea class="notes-modal-textarea" id="notesModalTextarea" maxlength="500" placeholder="Add notes, details, or reminders..."></textarea>
            </div>
            <div class="notes-modal-footer">
                <button type="button" class="notes-modal-btn notes-modal-btn-secondary" id="notesModalCancelBtn">Cancel</button>
                <button type="button" class="notes-modal-btn notes-modal-btn-primary" id="notesModalSaveBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Task Detail Modal (Read-only view) -->
    <div class="modal-overlay" id="taskDetailModal">
        <div class="task-detail-modal">
            <div class="task-detail-header">
                <button type="button" class="task-detail-close" id="taskDetailClose" aria-label="Close">&times;</button>
            </div>
            <div class="task-detail-body">
                <h2 class="task-detail-name" id="taskDetailName">Task Name</h2>
                <div class="task-detail-meta">
                    <div class="task-detail-category" id="taskDetailCategory">
                        <span class="task-detail-category-dot"></span>
                        <span class="task-detail-category-name">General</span>
                    </div>
                    <div class="task-detail-type" id="taskDetailType">One-time</div>
                </div>
                <div class="task-detail-notes-section">
                    <div class="task-detail-notes-label">Notes</div>
                    <div class="task-detail-notes" id="taskDetailNotes">No notes added yet</div>
                </div>
            </div>
            <div class="task-detail-footer">
                <button type="button" class="task-detail-edit-btn" id="taskDetailEditBtn">Edit Task</button>
            </div>
        </div>
    </div>

    <!-- Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="bottomSheetOverlay"></div>
    <div class="bottom-sheet" id="bottomSheet">
        <div class="sheet-handle"></div>
        <div class="sheet-header">
            <span class="sheet-date" id="sheetDate">Wednesday, Jan 15</span>
            <button type="button" class="sheet-close" id="sheetCloseBtn">&times;</button>
        </div>
        <div class="sheet-tasks" id="sheetTasks"></div>
    </div>

    <!-- Level Up Toast -->
    <div class="level-up-toast" id="levelUpToast">
        <div class="level-up-toast-content">
            <span class="level-up-toast-emoji">🎉</span>
            <span class="level-up-toast-text">Level Up! You're now <span class="level-up-toast-level" id="toastLevel">Level 2</span></span>
        </div>
    </div>

    <!-- Undo Toast -->
    <div class="undo-toast" id="undoToast">
        <span class="undo-toast-message" id="undoToastMessage">Action completed</span>
        <button type="button" class="undo-toast-btn" id="undoToastBtn">Undo</button>
    </div>

    <script>
        // DOM Elements
        const currentLevelEl = document.getElementById('currentLevel');
        const currentXpEl = document.getElementById('currentXp');
        const xpToNextEl = document.getElementById('xpToNext');
        const progressBar = document.getElementById('progressBar');
        const prevDateBtn = document.getElementById('prevDate');
        const nextDateBtn = document.getElementById('nextDate');
        const todayBtn = document.getElementById('todayBtn');
        const dayViewBtn = document.getElementById('dayViewBtn');
        const weekViewBtn = document.getElementById('weekViewBtn');
        const monthViewBtn = document.getElementById('monthViewBtn');
        const planViewBtn = document.getElementById('planViewBtn');
        const statsViewBtn = document.getElementById('statsViewBtn');
        const dayViewContainer = document.getElementById('dayViewContainer');
        const weekViewContainer = document.getElementById('weekViewContainer');
        const monthContainer = document.getElementById('monthContainer');
        const planContainer = document.getElementById('planContainer');
        const statsContainer = document.getElementById('statsContainer');
        const planWeekTitle = document.getElementById('planWeekTitle');
        const planWeekStats = document.getElementById('planWeekStats');
        const planDays = document.getElementById('planDays');
        const planPrevWeek = document.getElementById('planPrevWeek');
        const planNextWeek = document.getElementById('planNextWeek');
        const statTotalCompleted = document.getElementById('statTotalCompleted');
        const statStreak = document.getElementById('statStreak');
        const statCompletionRate = document.getElementById('statCompletionRate');
        const statLevel = document.getElementById('statLevel');
        const weekDateRange = document.getElementById('weekDateRange');
        const weekProgressText = document.getElementById('weekProgressText');
        const weekProgressPercent = document.getElementById('weekProgressPercent');
        const weekProgressFill = document.getElementById('weekProgressFill');
        const categoryBreakdown = document.getElementById('categoryBreakdown');
        const timeAllocationSummary = document.getElementById('timeAllocationSummary');
        const timeAllocationBars = document.getElementById('timeAllocationBars');
        const streakAchievementsEl = document.getElementById('streakAchievements');
        const completionAchievementsEl = document.getElementById('completionAchievements');
        const streakProgressEl = document.getElementById('streakProgress');
        const completionProgressEl = document.getElementById('completionProgress');
        const celebrationOverlay = document.getElementById('celebrationOverlay');
        const celebrationName = document.getElementById('celebrationName');
        const celebrationReq = document.getElementById('celebrationReq');
        const celebrationXp = document.getElementById('celebrationXp');
        const dayTimelineContainer = document.getElementById('dayTimelineContainer');
        const dayTimeline = document.getElementById('dayTimeline');
        const timelineUntimedSection = document.getElementById('timelineUntimedSection');
        const timelineUntimedTasks = document.getElementById('timelineUntimedTasks');
        const untimedCountBadge = document.getElementById('untimedCountBadge');
        const weekScrollContainer = document.getElementById('weekScrollContainer');
        const weekDayHeaders = document.getElementById('weekDayHeaders');
        const weekHourMarkers = document.getElementById('weekHourMarkers');
        const weekDaysGrid = document.getElementById('weekDaysGrid');
        const weekUntimedContainer = document.getElementById('weekUntimedContainer');
        const weekUntimedCount = document.getElementById('weekUntimedCount');
        const weekUntimedDays = document.getElementById('weekUntimedDays');
        const monthGrid = document.getElementById('monthGrid');
        const monthList = document.getElementById('monthList');
        const dateDisplayContainer = document.getElementById('dateDisplayContainer');
        const dateBadge = document.getElementById('dateBadge');
        const dateBadgeMonth = document.getElementById('dateBadgeMonth');
        const dateBadgeDay = document.getElementById('dateBadgeDay');
        const dateBadgeWeekday = document.getElementById('dateBadgeWeekday');
        const fabButton = document.getElementById('fabButton');
        const createTaskModal = document.getElementById('createTaskModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalTaskInput = document.getElementById('modalTaskInput');
        const modalCategorySelect = document.getElementById('modalCategorySelect');
        const categoryIndicator = document.getElementById('categoryIndicator');
        const modalTypeSelect = document.getElementById('modalTypeSelect');
        const modalDateInput = document.getElementById('modalDateInput');
        const modalDateField = document.getElementById('modalDateField');
        const modalDateLabel = document.getElementById('modalDateLabel');
        const modalEveryNDaysField = document.getElementById('modalEveryNDaysField');
        const modalEveryNDaysInput = document.getElementById('modalEveryNDaysInput');
        const modalMonthlyField = document.getElementById('modalMonthlyField');
        const modalMonthlyDaySelect = document.getElementById('modalMonthlyDaySelect');
        const modalDayPickerField = document.getElementById('modalDayPickerField');
        const modalDayPicker = document.getElementById('modalDayPicker');
        const modalTimeToggle = document.getElementById('modalTimeToggle');
        const timeInputWrapper = document.getElementById('timeInputWrapper');
        const modalTimeInput = document.getElementById('modalTimeInput');
        const modalDurationSelect = document.getElementById('modalDurationSelect');
        const modalSubmitBtn = document.getElementById('modalSubmitBtn');
        const modalNotesInput = document.getElementById('modalNotesInput');
        const notesCharCount = document.getElementById('notesCharCount');
        const notesModal = document.getElementById('notesModal');
        const notesModalTitle = document.getElementById('notesModalTitle');
        const notesModalTextarea = document.getElementById('notesModalTextarea');
        const notesModalClose = document.getElementById('notesModalClose');
        const notesModalCancelBtn = document.getElementById('notesModalCancelBtn');
        const notesModalSaveBtn = document.getElementById('notesModalSaveBtn');
        const deleteModal = document.getElementById('deleteModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalText = document.getElementById('modalText');
        const bottomSheetOverlay = document.getElementById('bottomSheetOverlay');
        const bottomSheet = document.getElementById('bottomSheet');
        const sheetDate = document.getElementById('sheetDate');
        const sheetTasks = document.getElementById('sheetTasks');
        const sheetCloseBtn = document.getElementById('sheetCloseBtn');
        const dateNav = document.getElementById('dateNav');
        const resetAchievementsBtn = document.getElementById('resetAchievementsBtn');
        const confirmOverlay = document.getElementById('confirmOverlay');
        const confirmCancel = document.getElementById('confirmCancel');
        const confirmReset = document.getElementById('confirmReset');
        const modalTitleText = document.getElementById('modalTitleText');
        const planHelpBtn = document.getElementById('planHelpBtn');
        const weekNavBar = document.getElementById('weekNavBar');
        const weekNavPrev = document.getElementById('weekNavPrev');
        const weekNavNext = document.getElementById('weekNavNext');
        const planHelpOverlay = document.getElementById('planHelpOverlay');
        const taskDetailModal = document.getElementById('taskDetailModal');
        const taskDetailClose = document.getElementById('taskDetailClose');
        const taskDetailName = document.getElementById('taskDetailName');
        const taskDetailCategory = document.getElementById('taskDetailCategory');
        const taskDetailType = document.getElementById('taskDetailType');
        const taskDetailNotes = document.getElementById('taskDetailNotes');
        const taskDetailEditBtn = document.getElementById('taskDetailEditBtn');
        const levelUpToast = document.getElementById('levelUpToast');
        const toastLevel = document.getElementById('toastLevel');
        const undoToast = document.getElementById('undoToast');
        const undoToastMessage = document.getElementById('undoToastMessage');
        const undoToastBtn = document.getElementById('undoToastBtn');

        // State
        let totalXp = 0;
        let dailyTaskCounter = 0;
        let taskIdCounter = 0;
        let pendingDeleteTask = null;
        let pendingDeleteContext = null;
        let currentView = 'day';
        let viewingDate = new Date();
        let viewingMonth = new Date().getMonth();
        let viewingYear = new Date().getFullYear();
        let selectedSheetDate = null;
        let tasks = []; // Master task list
        let taskCompletions = {}; // Track completions by date

        // Edit mode state
        let isEditMode = false;
        let editingTaskId = null;

        // Flag to prevent re-renders during task completion
        let isCompletingWeekTask = false;
        let editingTaskDateStr = null;

        // Task detail modal state
        let currentDetailTaskId = null;
        let currentDetailDateStr = null;

        // Undo system state
        let lastAction = null;
        let undoTimeout = null;

        // Swipe tracking
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const SWIPE_THRESHOLD = 50;

        // Constants
        const STORAGE_KEY = 'lifeGamifiedData';
        const VIEW_STORAGE_KEY = 'lifeGamifiedView';
        const LEVEL_STORAGE_KEY = 'lifeGamifiedLevel';
        const XP_PER_LEVEL = 100;

        // Level tracking for celebrations
        let previousLevel = parseInt(localStorage.getItem(LEVEL_STORAGE_KEY)) || 1;
        const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
        const dayAbbrev = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];

        const repeatIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>`;

        // Category Colors
        const CATEGORY_COLORS = {
            general: '#9E9E9E',
            health: '#4CAF50',
            learning: '#2196F3',
            creative: '#9C27B0',
            wellness: '#00BCD4',
            productivity: '#FF9800',
            social: '#E91E63'
        };

        function getCategoryColor(category) {
            return CATEGORY_COLORS[category] || CATEGORY_COLORS.general;
        }

        // Achievement Definitions
        const ACHIEVEMENTS = {
            streak: [
                { id: 'streak_3', name: 'Spark', requirement: '3-day streak', threshold: 3, xp: 50 },
                { id: 'streak_7', name: 'On Fire', requirement: '7-day streak', threshold: 7, xp: 100 },
                { id: 'streak_14', name: 'Blazing', requirement: '14-day streak', threshold: 14, xp: 200 },
                { id: 'streak_30', name: 'Unstoppable', requirement: '30-day streak', threshold: 30, xp: 500 },
                { id: 'streak_100', name: 'Legendary', requirement: '100-day streak', threshold: 100, xp: 1000 }
            ],
            completion: [
                { id: 'complete_1', name: 'First Steps', requirement: '1 task completed', threshold: 1, xp: 10 },
                { id: 'complete_10', name: 'Getting Started', requirement: '10 tasks completed', threshold: 10, xp: 50 },
                { id: 'complete_50', name: 'Consistent', requirement: '50 tasks completed', threshold: 50, xp: 200 },
                { id: 'complete_100', name: 'Centurion', requirement: '100 tasks completed', threshold: 100, xp: 500 },
                { id: 'complete_500', name: 'Task Master', requirement: '500 tasks completed', threshold: 500, xp: 2000 }
            ]
        };

        // Unlocked achievements stored by id with unlock date
        let unlockedAchievements = {};

        // Utility Functions
        function getTodayIndex() {
            const jsDay = new Date().getDay();
            return jsDay === 0 ? 6 : jsDay - 1;
        }

        function getWeekdayFromDate(date) {
            const jsDay = date.getDay();
            return jsDay === 0 ? 6 : jsDay - 1;
        }

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatDateForDisplay(date) {
            const dayName = days[getWeekdayFromDate(date)];
            const monthName = monthNames[date.getMonth()];
            return `${dayName}, ${monthName} ${date.getDate()}`;
        }

        function formatDateShort(date) {
            const monthShort = monthNames[date.getMonth()].slice(0, 3);
            return `${monthShort} ${date.getDate()}`;
        }

        function getWeekDates(centerDate) {
            const weekday = getWeekdayFromDate(centerDate);
            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(centerDate);
                date.setDate(centerDate.getDate() - weekday + i);
                weekDates.push(date);
            }
            return weekDates;
        }

        function isSameDay(date1, date2) {
            return formatDateForInput(date1) === formatDateForInput(date2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getPatternLabel(pattern) {
            if (!pattern) return 'Daily';
            if (pattern === 'daily') return 'Daily';

            const indices = pattern.split(',').map(Number);
            if (indices.length === 7) return 'Daily';
            if (indices.length === 5 && indices.join(',') === '0,1,2,3,4') return 'Weekdays';
            if (indices.length === 2 && indices.join(',') === '5,6') return 'Weekends';

            return indices.map(i => dayAbbrev[i]).join(', ');
        }

        function getRepeatLabel(task) {
            if (!task) return 'Repeating';
            if (task.type === 'daily') return 'Daily';
            if (task.type === 'every-n-days' && task.repeatInterval) {
                return `Every ${task.repeatInterval} days`;
            }
            if (task.type === 'monthly' && task.monthlyDate) {
                const daySuffix = (day) => {
                    if (day >= 11 && day <= 13) return 'th';
                    switch (day % 10) {
                        case 1: return 'st';
                        case 2: return 'nd';
                        case 3: return 'rd';
                        default: return 'th';
                    }
                };
                return `Monthly on ${task.monthlyDate}${daySuffix(task.monthlyDate)}`;
            }
            if (task.type === 'custom' && task.pattern) {
                return getPatternLabel(task.pattern);
            }
            return 'Repeating';
        }

        function getRecurringTooltip(task) {
            if (!task) return '';
            if (task.type === 'daily') return 'Repeats daily';
            if (task.type === 'every-n-days' && task.repeatInterval) {
                return `Repeats every ${task.repeatInterval} days`;
            }
            if (task.type === 'monthly' && task.monthlyDate) {
                const daySuffix = (day) => {
                    if (day >= 11 && day <= 13) return 'th';
                    switch (day % 10) {
                        case 1: return 'st';
                        case 2: return 'nd';
                        case 3: return 'rd';
                        default: return 'th';
                    }
                };
                return `Monthly on the ${task.monthlyDate}${daySuffix(task.monthlyDate)}`;
            }
            if (task.type === 'custom' && task.pattern) {
                const label = getPatternLabel(task.pattern);
                if (label === 'Daily') return 'Repeats daily';
                if (label === 'Weekdays') return 'Repeats on weekdays';
                if (label === 'Weekends') return 'Repeats on weekends';
                return `Weekly: ${label}`;
            }
            return 'Repeating task';
        }

        // Completion Tracking
        function isTaskCompletedForDate(taskId, dateStr) {
            return taskCompletions[taskId]?.[dateStr] === true;
        }

        function setTaskCompletedForDate(taskId, dateStr, completed) {
            if (!taskCompletions[taskId]) {
                taskCompletions[taskId] = {};
            }
            if (completed) {
                taskCompletions[taskId][dateStr] = true;
            } else {
                delete taskCompletions[taskId][dateStr];
            }
        }

        function recalculateXpFromCompletions() {
            let calculatedXp = 0;
            for (const taskId in taskCompletions) {
                for (const dateStr in taskCompletions[taskId]) {
                    if (taskCompletions[taskId][dateStr] === true) {
                        calculatedXp += 10;
                    }
                }
            }
            return calculatedXp;
        }

        // Level System
        function getLevel(xp) {
            return Math.floor(xp / XP_PER_LEVEL) + 1;
        }

        function getXpInCurrentLevel(xp) {
            return xp % XP_PER_LEVEL;
        }

        function updateLevelDisplay() {
            console.log('[DEBUG] updateLevelDisplay called - isCompletingWeekTask:', isCompletingWeekTask);
            const level = getLevel(totalXp);
            const xpInLevel = getXpInCurrentLevel(totalXp);
            const progress = (xpInLevel / XP_PER_LEVEL) * 100;

            // Check for level up
            if (level > previousLevel) {
                celebrateLevelUp(level);
                previousLevel = level;
                localStorage.setItem(LEVEL_STORAGE_KEY, level.toString());
            }

            currentLevelEl.textContent = level;
            currentXpEl.textContent = xpInLevel;
            xpToNextEl.textContent = XP_PER_LEVEL;
            progressBar.style.width = progress + '%';

            // Add glow effect when near level-up (>90%)
            if (progress > 90) {
                progressBar.classList.add('near-levelup');
            } else {
                progressBar.classList.remove('near-levelup');
            }
        }

        // Level Up Celebration
        function celebrateLevelUp(newLevel) {
            // Hide undo toast during celebration
            undoToast.classList.add('hidden-for-celebration');

            // Show toast notification
            showLevelUpToast(newLevel);

            // Confetti celebration - elegant gold and white bursts
            const colors = ['#FFD700', '#FFF8DC', '#FFFFFF', '#F5DEB3'];
            const duration = 2000;
            const end = Date.now() + duration;

            // Re-enable undo toast after celebration
            setTimeout(() => {
                undoToast.classList.remove('hidden-for-celebration');
            }, 3000);

            // First burst - center bottom
            confetti({
                particleCount: 50,
                spread: 60,
                origin: { x: 0.5, y: 1 },
                colors: colors,
                startVelocity: 45,
                gravity: 0.8,
                scalar: 1.2,
                drift: 0
            });

            // Continuous elegant bursts
            const interval = setInterval(() => {
                if (Date.now() > end) {
                    clearInterval(interval);
                    return;
                }

                // Alternating left and right bursts
                confetti({
                    particleCount: 25,
                    angle: 60,
                    spread: 40,
                    origin: { x: 0.3, y: 1 },
                    colors: colors,
                    startVelocity: 35,
                    gravity: 0.9,
                    scalar: 1
                });

                confetti({
                    particleCount: 25,
                    angle: 120,
                    spread: 40,
                    origin: { x: 0.7, y: 1 },
                    colors: colors,
                    startVelocity: 35,
                    gravity: 0.9,
                    scalar: 1
                });
            }, 300);
        }

        function showLevelUpToast(level) {
            toastLevel.textContent = `Level ${level}`;
            levelUpToast.classList.add('visible');

            // Auto-hide after 3 seconds
            setTimeout(() => {
                levelUpToast.classList.remove('visible');
            }, 3000);
        }

        // Undo System (only for deletions)
        function showUndoToast(message, undoCallback) {
            // Clear any existing timeout
            if (undoTimeout) {
                clearTimeout(undoTimeout);
            }

            // Store the action
            lastAction = {
                callback: undoCallback,
                timestamp: Date.now()
            };

            // Update and show toast with minimal format
            undoToastMessage.textContent = message + ' •';
            undoToast.classList.add('visible');

            // Auto-hide after 3 seconds
            undoTimeout = setTimeout(() => {
                hideUndoToast();
            }, 3000);
        }

        function hideUndoToast() {
            undoToast.classList.remove('visible');
            lastAction = null;
            if (undoTimeout) {
                clearTimeout(undoTimeout);
                undoTimeout = null;
            }
        }

        function executeUndo() {
            if (lastAction && lastAction.callback) {
                lastAction.callback();
            }
            hideUndoToast();
        }

        // Undo button click handler
        undoToastBtn.addEventListener('click', executeUndo);

        // Task Data Functions
        function getTasksForDate(date) {
            const dateStr = formatDateForInput(date);
            const weekdayIndex = getWeekdayFromDate(date);

            return tasks.filter(task => {
                if (task.type === 'daily') {
                    return true;
                } else if (task.type === 'custom') {
                    const taskDays = task.pattern.split(',').map(Number);
                    return taskDays.includes(weekdayIndex);
                } else if (task.type === 'every-n-days') {
                    // Calculate if this date falls on the interval from startDate
                    if (!task.startDate || !task.repeatInterval) return false;
                    const startDate = new Date(task.startDate + 'T00:00:00');
                    const checkDate = new Date(dateStr + 'T00:00:00');
                    const diffTime = checkDate.getTime() - startDate.getTime();
                    const diffDays = Math.round(diffTime / (1000 * 60 * 60 * 24));
                    // Show on start date (diffDays === 0) and every N days after
                    return diffDays >= 0 && diffDays % task.repeatInterval === 0;
                } else if (task.type === 'monthly') {
                    // Show on the same day of each month
                    if (!task.monthlyDate) return false;
                    const checkDateObj = new Date(dateStr + 'T00:00:00');
                    const dayOfMonth = checkDateObj.getDate();
                    // Handle months with fewer days (e.g., Feb 30 → Feb 28)
                    const lastDayOfMonth = new Date(checkDateObj.getFullYear(), checkDateObj.getMonth() + 1, 0).getDate();
                    if (task.monthlyDate > lastDayOfMonth) {
                        return dayOfMonth === lastDayOfMonth;
                    }
                    return dayOfMonth === task.monthlyDate;
                } else {
                    // One-time task
                    return task.date === dateStr;
                }
            }).map(task => {
                const completionKey = task.dailyId || task.id;
                const isRepeating = task.type !== 'onetime';
                const completionDate = isRepeating ? dateStr : task.date;
                return {
                    ...task,
                    completed: isTaskCompletedForDate(completionKey, completionDate)
                };
            }).sort((a, b) => {
                // Tasks with times come first, sorted by time
                // Tasks without times come after, in original order
                const aHasTime = !!a.time;
                const bHasTime = !!b.time;

                if (aHasTime && bHasTime) {
                    // Both have times - sort by time (earliest first)
                    return a.time.localeCompare(b.time);
                } else if (aHasTime && !bHasTime) {
                    // a has time, b doesn't - a comes first
                    return -1;
                } else if (!aHasTime && bHasTime) {
                    // b has time, a doesn't - b comes first
                    return 1;
                }
                // Neither has time - keep original order
                return 0;
            });
        }

        // Date Navigation
        function navigateDay(delta) {
            const oldDate = new Date(viewingDate);
            viewingDate.setDate(viewingDate.getDate() + delta);

            // Update month/year if needed
            viewingMonth = viewingDate.getMonth();
            viewingYear = viewingDate.getFullYear();

            updateDateDisplay();

            if (currentView === 'day') {
                // Animate transition
                const direction = delta > 0 ? 'left' : 'right';
                dayTimelineContainer.classList.add(`slide-${direction}`);
                setTimeout(() => {
                    dayTimelineContainer.classList.remove(`slide-${direction}`);
                    dayTimelineContainer._hasScrolled = false; // Reset scroll flag for new day
                    renderDayView();
                }, 150);
            } else if (currentView === 'week') {
                // Check if we moved to a different week
                const oldWeekStart = getWeekDates(oldDate)[0];
                const newWeekStart = getWeekDates(viewingDate)[0];
                if (!isSameDay(oldWeekStart, newWeekStart)) {
                    renderWeekView();
                } else {
                    syncWeekStrip();
                    scrollCarouselToDay();
                }
            }
        }

        function goToToday() {
            viewingDate = new Date();
            viewingMonth = viewingDate.getMonth();
            viewingYear = viewingDate.getFullYear();
            updateDateDisplay();

            if (currentView === 'month') {
                // Always re-render grid view on desktop
                renderMonthGridView();

                // For mobile: Check if today's month is already loaded
                const todaySection = monthList.querySelector('.month-date-section.today');
                if (todaySection) {
                    todaySection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    renderMonthListView();
                    // Scroll to current month after render
                    setTimeout(() => {
                        const newTodaySection = monthList.querySelector('.month-date-section.today');
                        if (newTodaySection) {
                            newTodaySection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 100);
                }
            } else if (currentView === 'week') {
                // Re-render week view centered on today
                renderWeekView();
                // On mobile, scroll to today's column
                setTimeout(() => {
                    const isMobile = window.innerWidth < 768;
                    const gridContainer = isMobile ? weekDaysGrid : document.getElementById('weekTimelineGrid');
                    const todayColumn = gridContainer ? gridContainer.querySelector('.week-day-column.today') : null;
                    if (todayColumn && isMobile) {
                        todayColumn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 50);
            } else if (currentView === 'day') {
                // Reset scroll flag so we scroll to current time
                dayTimelineContainer._hasScrolled = false;
                renderDayView();
            } else {
                renderCurrentView();
            }
        }

        function updateDateDisplay() {
            // Clear container and rebuild based on view
            dateDisplayContainer.innerHTML = '';

            if (currentView === 'day') {
                // Day View: Prominent badge with month, day number, weekday
                const badge = document.createElement('div');
                badge.className = 'date-badge';
                badge.innerHTML = `
                    <span class="date-badge-month">${monthNames[viewingDate.getMonth()].slice(0, 3)}</span>
                    <span class="date-badge-day">${viewingDate.getDate()}</span>
                    <span class="date-badge-weekday">${days[getWeekdayFromDate(viewingDate)]}</span>
                `;
                dateDisplayContainer.appendChild(badge);
            } else if (currentView === 'week') {
                // Week View: Show week range
                const weekDates = getWeekDates(viewingDate);
                const startDate = weekDates[0];
                const endDate = weekDates[6];

                const textDiv = document.createElement('div');
                textDiv.className = 'date-text';

                const startMonth = monthNames[startDate.getMonth()].slice(0, 3);
                const endMonth = monthNames[endDate.getMonth()].slice(0, 3);

                if (startDate.getMonth() === endDate.getMonth()) {
                    textDiv.textContent = `${startMonth} ${startDate.getDate()} - ${endDate.getDate()}`;
                } else {
                    textDiv.textContent = `${startMonth} ${startDate.getDate()} - ${endMonth} ${endDate.getDate()}`;
                }

                const subDiv = document.createElement('div');
                subDiv.className = 'date-text-sub';
                subDiv.textContent = startDate.getFullYear();

                textDiv.appendChild(subDiv);
                dateDisplayContainer.appendChild(textDiv);
            } else {
                // Month View: Month and year
                const textDiv = document.createElement('div');
                textDiv.className = 'date-text';
                textDiv.textContent = `${monthNames[viewingMonth]} ${viewingYear}`;
                dateDisplayContainer.appendChild(textDiv);
            }

            // Highlight Today button if viewing today
            const isToday = isSameDay(viewingDate, new Date());
            todayBtn.classList.toggle('active', isToday);
        }

        // View Management - Optimized for fast switching
        let lastRenderedView = null;
        let viewRenderTimeout = null;

        let viewTransitionTimeout = null;
        let isInitialViewLoad = true;

        function setView(view) {
            // Cancel any pending transitions or renders
            if (viewRenderTimeout) {
                cancelAnimationFrame(viewRenderTimeout);
                viewRenderTimeout = null;
            }
            if (viewTransitionTimeout) {
                clearTimeout(viewTransitionTimeout);
                viewTransitionTimeout = null;
            }

            const containers = [dayViewContainer, weekViewContainer, monthContainer, planContainer, statsContainer];
            const buttons = [dayViewBtn, weekViewBtn, monthViewBtn, planViewBtn, statsViewBtn];
            const viewMap = { day: 0, week: 1, month: 2, plan: 3, stats: 4 };
            const viewIndex = viewMap[view];
            const oldViewIndex = viewMap[currentView];

            // If same view, just update
            if (view === currentView && !isInitialViewLoad) {
                renderViewContent(view);
                return;
            }

            // Update buttons immediately
            buttons.forEach((b, i) => b.classList.toggle('active', i === viewIndex));

            // Get old and new containers
            const oldContainer = containers[oldViewIndex];
            const newContainer = containers[viewIndex];

            // Skip animation on initial load
            if (isInitialViewLoad) {
                isInitialViewLoad = false;
                currentView = view;
                document.body.dataset.view = view;

                if (view === 'month') {
                    viewingMonth = viewingDate.getMonth();
                    viewingYear = viewingDate.getFullYear();
                }

                if (view !== 'stats' && view !== 'plan') {
                    updateDateDisplay();
                }

                containers.forEach((c, i) => {
                    c.classList.remove('active', 'fade-out', 'fade-in');
                    if (i === viewIndex) {
                        c.classList.add('active');
                    }
                });

                renderViewContent(view);
                lastRenderedView = view;
                localStorage.setItem(VIEW_STORAGE_KEY, view);
                return;
            }

            // Fade out old view
            if (oldContainer) {
                oldContainer.classList.add('fade-out');
            }

            // After fade-out, switch views
            viewTransitionTimeout = setTimeout(() => {
                // Update state
                currentView = view;
                document.body.dataset.view = view;

                // For Month view, update viewingMonth/viewingYear FIRST
                if (view === 'month') {
                    viewingMonth = viewingDate.getMonth();
                    viewingYear = viewingDate.getFullYear();
                }

                // Update header (not for stats/plan views)
                if (view !== 'stats' && view !== 'plan') {
                    updateDateDisplay();
                }

                // Hide old, show new
                containers.forEach((c, i) => {
                    c.classList.remove('active', 'fade-out', 'fade-in');
                    if (i === viewIndex) {
                        c.classList.add('fade-in');
                    }
                });

                // Scroll to top
                window.scrollTo(0, 0);

                // Render content
                renderViewContent(view);

                // Clean up fade-in class after animation
                setTimeout(() => {
                    newContainer.classList.remove('fade-in');
                    newContainer.classList.add('active');
                }, 200);

                lastRenderedView = view;
                localStorage.setItem(VIEW_STORAGE_KEY, view);
            }, 200);
        }

        function renderViewContent(view) {
            if (view === 'day') {
                renderDayView();
            } else if (view === 'week') {
                renderWeekView();
            } else if (view === 'plan') {
                renderPlanView();
            } else if (view === 'stats') {
                renderStatsView();
            } else {
                renderMonthView();
            }
        }

        function renderCurrentView() {
            console.log('[DEBUG] renderCurrentView called - currentView:', currentView, 'isCompletingWeekTask:', isCompletingWeekTask);
            // Don't re-render Week view during task completion (prevents position jumping)
            if (isCompletingWeekTask && currentView === 'week') {
                console.log('[DEBUG] renderCurrentView BLOCKED for week view');
                return;
            }
            renderViewContent(currentView);
        }

        // Update only a specific date section in Month view (avoids scroll reset)
        function updateMonthDateSection(dateStr) {
            const section = monthList.querySelector(`.month-date-section[data-date="${dateStr}"]`);
            if (!section) return false;

            // Parse the date
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            const tasksForDay = getTasksForDate(date);
            const hasNoTasks = tasksForDay.length === 0;

            // Update section classes
            section.classList.toggle('empty-section', hasNoTasks);

            // Update task count badge
            const countBadge = section.querySelector('.month-task-count');
            const emptyLabel = section.querySelector('.month-empty-label');
            const header = section.querySelector('.month-date-header');
            const isToday = section.classList.contains('today');

            if (hasNoTasks) {
                // Remove count badge if exists
                if (countBadge) countBadge.remove();
                // Add empty label if not today and doesn't exist
                if (!isToday && !emptyLabel) {
                    const addIndicator = header.querySelector('.month-add-indicator');
                    const newEmptyLabel = document.createElement('span');
                    newEmptyLabel.className = 'month-empty-label';
                    newEmptyLabel.textContent = 'No tasks';
                    header.insertBefore(newEmptyLabel, addIndicator);
                }
            } else {
                // Remove empty label if exists
                if (emptyLabel) emptyLabel.remove();
                // Update or create count badge
                if (countBadge) {
                    countBadge.textContent = `${tasksForDay.length} task${tasksForDay.length > 1 ? 's' : ''}`;
                } else {
                    const addIndicator = header.querySelector('.month-add-indicator');
                    const newCountBadge = document.createElement('span');
                    newCountBadge.className = 'month-task-count';
                    newCountBadge.textContent = `${tasksForDay.length} task${tasksForDay.length > 1 ? 's' : ''}`;
                    header.insertBefore(newCountBadge, addIndicator);
                }
            }

            // Update tasks container
            let tasksContainer = section.querySelector('.month-date-tasks');

            if (hasNoTasks) {
                // Remove tasks container if exists
                if (tasksContainer) tasksContainer.remove();
            } else {
                // Create container if doesn't exist
                if (!tasksContainer) {
                    tasksContainer = document.createElement('div');
                    tasksContainer.className = 'month-date-tasks';
                    section.appendChild(tasksContainer);
                }

                // Rebuild task list
                tasksContainer.innerHTML = '';
                const tasksList = document.createElement('div');
                tasksList.className = 'day-tasks';

                tasksForDay.forEach(task => {
                    const taskEl = createTaskElement(task, dateStr);
                    tasksList.appendChild(taskEl);
                });

                tasksContainer.appendChild(tasksList);
            }

            return true;
        }

        // Update only a specific date cell in Month Grid view (desktop)
        function updateMonthGridDateCell(dateStr) {
            const dayCell = monthGrid.querySelector(`.month-day[data-date="${dateStr}"]`);
            if (!dayCell) return false;

            // Parse the date
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            const tasksForDay = getTasksForDate(date);

            // Remove existing task previews and "more" button (keep day number)
            const existingPreviews = dayCell.querySelectorAll('.month-task-preview, .month-more-tasks');
            existingPreviews.forEach(el => el.remove());

            // Rebuild task previews
            const maxVisible = 2;
            if (tasksForDay.length > 0) {
                const tasksToShow = tasksForDay.slice(0, maxVisible);

                tasksToShow.forEach(task => {
                    const preview = document.createElement('div');
                    preview.className = 'month-task-preview' + (task.completed ? ' completed' : '');
                    preview.dataset.taskId = task.id;
                    preview.dataset.dateStr = dateStr;
                    if (task.dailyId) preview.dataset.dailyId = task.dailyId;
                    if (task.pattern) preview.dataset.pattern = task.pattern;
                    if (task.type) preview.dataset.type = task.type;

                    // Checkbox
                    const checkbox = document.createElement('span');
                    checkbox.className = 'month-task-checkbox' + (task.completed ? ' checked' : '');

                    // Recurring indicator
                    const isRepeatingTask = task.type === 'daily' || task.type === 'custom' || task.type === 'every-n-days' || task.type === 'monthly';
                    let recurringEl = null;
                    if (isRepeatingTask) {
                        recurringEl = document.createElement('span');
                        recurringEl.className = 'recurring-indicator';
                        recurringEl.textContent = '↻';
                        recurringEl.dataset.tooltip = getRecurringTooltip(task);
                    }

                    // Category indicator
                    const indicator = document.createElement('span');
                    indicator.className = 'category-indicator';
                    indicator.style.background = getCategoryColor(task.category);

                    const text = document.createElement('span');
                    text.className = 'month-task-text';
                    text.textContent = task.name;

                    // Task text click handler - opens notes modal
                    text.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openNotesModal(task.id);
                    });

                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'month-task-delete';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleGridTaskDelete(preview);
                    });

                    preview.appendChild(checkbox);
                    if (recurringEl) preview.appendChild(recurringEl);
                    preview.appendChild(indicator);
                    preview.appendChild(text);
                    preview.appendChild(deleteBtn);

                    // Checkbox toggles completion
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleGridTask(preview);
                    });

                    dayCell.appendChild(preview);
                });

                if (tasksForDay.length > maxVisible) {
                    const moreBtn = document.createElement('div');
                    moreBtn.className = 'month-more-tasks';
                    moreBtn.textContent = `+${tasksForDay.length - maxVisible} more`;
                    moreBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        openBottomSheet(dateStr);
                    });
                    dayCell.appendChild(moreBtn);
                }
            }

            return true;
        }

        // Calculate task time ranges and detect overlaps
        function calculateTaskOverlaps(timedTasks) {
            const overlapInfo = new Map();

            // Calculate time ranges for each task
            const taskRanges = timedTasks.map(task => {
                const [hours, minutes] = task.time.split(':').map(Number);
                const startMinutes = hours * 60 + minutes;
                const duration = task.duration || 30;
                const endMinutes = startMinutes + duration;
                return {
                    task,
                    start: startMinutes,
                    end: endMinutes
                };
            });

            // Find overlapping tasks for each task
            taskRanges.forEach((range, index) => {
                const overlappingTasks = [];

                taskRanges.forEach((otherRange, otherIndex) => {
                    if (index === otherIndex) return;

                    // Check if ranges overlap
                    // Two ranges overlap if: start1 < end2 AND start2 < end1
                    if (range.start < otherRange.end && otherRange.start < range.end) {
                        overlappingTasks.push(otherRange.task);
                    }
                });

                overlapInfo.set(range.task.id, {
                    hasOverlap: overlappingTasks.length > 0,
                    overlappingWith: overlappingTasks,
                    totalInGroup: 0,
                    positionInGroup: 0
                });
            });

            // Group overlapping tasks and assign positions
            // Use a sweep line algorithm to find concurrent overlap groups
            const events = [];
            taskRanges.forEach((range, index) => {
                events.push({ time: range.start, type: 'start', index, range });
                events.push({ time: range.end, type: 'end', index, range });
            });

            // Sort events: by time, then starts before ends
            events.sort((a, b) => {
                if (a.time !== b.time) return a.time - b.time;
                return a.type === 'start' ? -1 : 1;
            });

            // Track active tasks and assign columns
            const activeRanges = new Set();
            const columnAssignments = new Map(); // task id -> column index
            const maxColumns = new Map(); // task id -> max concurrent tasks

            events.forEach(event => {
                if (event.type === 'start') {
                    // Find the first available column
                    const usedColumns = new Set();
                    activeRanges.forEach(r => {
                        const col = columnAssignments.get(r.task.id);
                        if (col !== undefined) usedColumns.add(col);
                    });

                    let col = 0;
                    while (usedColumns.has(col)) col++;
                    columnAssignments.set(event.range.task.id, col);

                    activeRanges.add(event.range);

                    // Update max columns for all active tasks
                    const currentCount = activeRanges.size;
                    activeRanges.forEach(r => {
                        const currentMax = maxColumns.get(r.task.id) || 1;
                        maxColumns.set(r.task.id, Math.max(currentMax, currentCount));
                    });
                } else {
                    activeRanges.delete(event.range);
                }
            });

            // Update overlap info with position data
            taskRanges.forEach(range => {
                const info = overlapInfo.get(range.task.id);
                const total = maxColumns.get(range.task.id) || 1;
                const position = columnAssignments.get(range.task.id) || 0;

                info.totalInGroup = total;
                info.positionInGroup = position;
            });

            return overlapInfo;
        }

        // Day View - Timeline Layout
        function renderDayView() {
            const dateStr = formatDateForInput(viewingDate);
            const tasksForDay = getTasksForDate(viewingDate);

            // Clear timeline
            dayTimeline.innerHTML = '';
            timelineUntimedTasks.innerHTML = '';

            // Separate timed and untimed tasks
            const timedTasks = tasksForDay.filter(t => t.time);
            const untimedTasks = tasksForDay.filter(t => !t.time);

            // Render untimed section (sticky at top, always visible when has tasks)
            untimedCountBadge.textContent = untimedTasks.length;
            if (untimedTasks.length > 0) {
                timelineUntimedSection.classList.add('has-tasks');
                untimedTasks.forEach(task => {
                    const taskEl = createTimelineUntimedTask(task, dateStr);
                    timelineUntimedTasks.appendChild(taskEl);
                });
            } else {
                timelineUntimedSection.classList.remove('has-tasks');
            }

            // Use 50px hours on mobile, 60px on desktop
            const isMobile = window.innerWidth <= 768;
            const hourHeight = isMobile ? 50 : 60;

            // Create 24 hour rows
            for (let hour = 0; hour < 24; hour++) {
                const hourRow = document.createElement('div');
                hourRow.className = 'timeline-hour';
                hourRow.style.top = `${hour * hourHeight}px`;
                hourRow.style.height = `${hourHeight}px`;

                const label = document.createElement('span');
                label.className = 'timeline-hour-label';
                label.textContent = `${hour.toString().padStart(2, '0')}:00`;
                hourRow.appendChild(label);

                // Click on hour row to add task at that time
                hourRow.addEventListener('click', (e) => {
                    const rect = hourRow.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const minutes = Math.floor(clickY / hourHeight * 60);
                    const roundedMinutes = Math.round(minutes / 15) * 15;
                    const timeStr = `${hour.toString().padStart(2, '0')}:${roundedMinutes.toString().padStart(2, '0')}`;
                    openCreateTaskModal(dateStr, timeStr);
                });

                dayTimeline.appendChild(hourRow);
            }

            // Tasks layer
            const tasksLayer = document.createElement('div');
            tasksLayer.className = 'timeline-tasks-layer';
            dayTimeline.appendChild(tasksLayer);

            // Calculate overlaps for timed tasks
            const overlapInfo = calculateTaskOverlaps(timedTasks);

            // Render timed tasks with overlap information
            timedTasks.forEach(task => {
                const taskOverlapData = overlapInfo.get(task.id);
                const taskBlock = createTimelineTaskBlock(task, dateStr, taskOverlapData);
                tasksLayer.appendChild(taskBlock);
            });

            // Current time indicator (only for today)
            const today = formatDateForInput(new Date());
            if (dateStr === today) {
                updateCurrentTimeIndicator();
            }
        }

        // Create untimed task element for timeline
        function createTimelineUntimedTask(task, dateStr) {
            const taskEl = document.createElement('div');
            taskEl.className = 'timeline-untimed-task' + (task.completed ? ' completed' : '');
            taskEl.dataset.taskId = task.id;
            taskEl.dataset.dateStr = dateStr;
            if (task.dailyId) taskEl.dataset.dailyId = task.dailyId;
            if (task.pattern) taskEl.dataset.pattern = task.pattern;
            if (task.type) taskEl.dataset.type = task.type;

            const checkedClass = task.completed ? ' checked' : '';
            const completedClass = task.completed ? ' completed' : '';
            const categoryColor = getCategoryColor(task.category);

            taskEl.innerHTML = `
                <div class="task-checkbox${checkedClass}"></div>
                <div class="category-indicator" style="background: ${categoryColor};"></div>
                <span class="task-name${completedClass}">${escapeHtml(task.name)}</span>
                <button type="button" class="delete-button">&times;</button>
            `;

            // Checkbox click handler
            const checkbox = taskEl.querySelector('.task-checkbox');
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleTimelineTask(taskEl, task);
            });

            // Delete button handler
            const deleteBtn = taskEl.querySelector('.delete-button');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleDeleteTask(taskEl);
            });

            // Task name click opens edit modal
            const taskNameEl = taskEl.querySelector('.task-name');
            taskNameEl.addEventListener('click', (e) => {
                e.stopPropagation();
                openEditTaskModal(task.id, dateStr);
            });

            return taskEl;
        }

        // Create timed task block for timeline
        function createTimelineTaskBlock(task, dateStr, overlapData = null) {
            const taskBlock = document.createElement('div');
            taskBlock.dataset.taskId = task.id;
            taskBlock.dataset.dateStr = dateStr;
            if (task.dailyId) taskBlock.dataset.dailyId = task.dailyId;

            // Use 50px hours on mobile, 60px on desktop
            const isMobile = window.innerWidth <= 768;
            const hourHeight = isMobile ? 50 : 60;
            const pixelsPerMinute = hourHeight / 60;

            // Calculate position from time (format: "HH:MM")
            const [hours, minutes] = task.time.split(':').map(Number);
            const topPosition = (hours * 60 + minutes) * pixelsPerMinute;
            taskBlock.style.top = `${topPosition}px`;

            // Calculate height from duration (default 30 min, minimum for touch)
            const duration = task.duration || 30;
            const calculatedHeight = duration * pixelsPerMinute;
            const minHeight = isMobile ? 30 : 40;
            const blockHeight = Math.max(calculatedHeight, minHeight);
            taskBlock.style.height = `${blockHeight}px`;

            // Handle overlap positioning
            const hasOverlap = overlapData && overlapData.hasOverlap;
            const totalInGroup = overlapData ? overlapData.totalInGroup : 1;
            const positionInGroup = overlapData ? overlapData.positionInGroup : 0;

            if (hasOverlap && totalInGroup > 1) {
                // Calculate width and left position based on number of overlapping tasks
                let widthPercent, gapPercent, leftPercent;

                if (totalInGroup === 2) {
                    // 2 tasks: 48% width each, 2% gap
                    widthPercent = 48;
                    gapPercent = 2;
                    leftPercent = positionInGroup * (widthPercent + gapPercent);
                } else {
                    // 3+ tasks: 32% width each, 2% gaps
                    widthPercent = 32;
                    gapPercent = 2;
                    leftPercent = positionInGroup * (widthPercent + gapPercent);
                }

                taskBlock.style.width = `${widthPercent}%`;
                taskBlock.style.left = `${leftPercent}%`;
                taskBlock.style.right = 'auto';
            }

            // Add compact class for short blocks (less than 1 hour)
            const isCompact = blockHeight < hourHeight;
            taskBlock.className = 'timeline-task-block' +
                (task.completed ? ' completed' : '') +
                (isCompact ? ' compact' : '') +
                (hasOverlap ? ' overlapping' : '');

            // Get category color and set styles
            const categoryColor = getCategoryColor(task.category);
            taskBlock.style.borderLeftColor = categoryColor;
            // Set background with 20% opacity
            taskBlock.style.background = hexToRgba(categoryColor, 0.2);

            // Format duration for display
            const durationDisplay = formatDuration(duration);

            // Check if task is recurring
            const isRepeating = task.type === 'daily' || task.type === 'custom' ||
                               task.type === 'every-n-days' || task.type === 'monthly';
            const recurringIcon = isRepeating ? '<span class="task-block-recurring">↻</span>' : '';

            // Build overlap warning if needed
            let overlapWarning = '';
            if (hasOverlap && overlapData.overlappingWith.length > 0) {
                const otherTaskNames = overlapData.overlappingWith
                    .map(t => t.name)
                    .slice(0, 3) // Limit to 3 names
                    .join(', ');
                const suffix = overlapData.overlappingWith.length > 3
                    ? ` +${overlapData.overlappingWith.length - 3} more`
                    : '';
                const tooltip = `Overlaps with: ${otherTaskNames}${suffix}`;
                overlapWarning = `<span class="overlap-warning" data-tooltip="${escapeHtml(tooltip)}">⚠️</span>`;
            }

            // Build content (no checkbox - use click/long press interaction)
            const timeFormatted = formatTime24Hour(task.time);
            let content = `
                ${overlapWarning}
                <div class="task-block-header">
                    <span class="task-block-time">${timeFormatted}</span>
                    <span class="task-block-duration">• ${durationDisplay}</span>
                    ${recurringIcon}
                </div>
                <div class="task-block-name">${escapeHtml(task.name)}</div>
            `;

            // Add notes preview if exists and block is tall enough
            if (task.notes && !isCompact && !hasOverlap) {
                const truncatedNotes = task.notes.length > 50
                    ? task.notes.substring(0, 50) + '...'
                    : task.notes;
                content += `<div class="task-block-notes">${escapeHtml(truncatedNotes)}</div>`;
            }

            taskBlock.innerHTML = content;

            // Interaction: Quick click = toggle completion, Long press = view details
            let longPressTimer = null;
            let isLongPress = false;

            // Mouse events for desktop
            taskBlock.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click
                isLongPress = false;
                taskBlock.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskBlock.classList.remove('pressing');
                    openTaskDetailModal(task.id, dateStr);
                }, 500);
            });

            taskBlock.addEventListener('mouseup', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskBlock.addEventListener('mouseleave', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskBlock.addEventListener('click', (e) => {
                e.stopPropagation();
                // Only toggle if it wasn't a long press
                if (!isLongPress) {
                    toggleTimelineTask(taskBlock, task);
                }
                isLongPress = false;
            });

            // Touch events for mobile
            taskBlock.addEventListener('touchstart', (e) => {
                isLongPress = false;
                taskBlock.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskBlock.classList.remove('pressing');
                    openTaskDetailModal(task.id, dateStr);
                }, 500);
            }, { passive: true });

            taskBlock.addEventListener('touchend', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                // If it wasn't a long press, toggle completion
                if (!isLongPress) {
                    e.preventDefault();
                    toggleTimelineTask(taskBlock, task);
                }
            });

            taskBlock.addEventListener('touchmove', (e) => {
                // Cancel long press if user moves finger (scrolling)
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: true });

            taskBlock.addEventListener('touchcancel', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            return taskBlock;
        }

        // Helper function to convert hex color to rgba
        function hexToRgba(hex, alpha) {
            // Handle shorthand hex
            let r, g, b;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else {
                r = parseInt(hex.slice(1, 3), 16);
                g = parseInt(hex.slice(3, 5), 16);
                b = parseInt(hex.slice(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper function to format duration
        function formatDuration(minutes) {
            if (minutes < 60) {
                return `${minutes}m`;
            } else if (minutes % 60 === 0) {
                return `${minutes / 60}h`;
            } else {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return `${hours}h ${mins}m`;
            }
        }

        // Helper function to format time as 24-hour (HH:MM)
        function formatTime24Hour(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        // Toggle task completion for week view (works with taskId and dateStr)
        function toggleWeekTask(taskId, dateStr, taskEl) {
            console.log('[DEBUG] toggleWeekTask START - setting flag to TRUE');
            // Set flag to prevent re-renders during completion
            isCompletingWeekTask = true;

            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                console.log('[DEBUG] Task not found, clearing flag');
                isCompletingWeekTask = false;
                return;
            }

            const completionKey = taskId;
            const completionDate = task.type === 'onetime' ? task.date : dateStr;
            const wasCompleted = isTaskCompletedForDate(completionKey, completionDate);
            const isNowCompleted = !wasCompleted;

            setTaskCompletedForDate(completionKey, completionDate, isNowCompleted);

            // Update UI based on element type (CSS classes only, no DOM rebuild)
            if (taskEl.classList.contains('week-untimed-item')) {
                // Untimed task in separate section above grid
                const checkbox = taskEl.querySelector('.item-checkbox');
                const name = taskEl.querySelector('.item-name');
                if (checkbox) checkbox.classList.toggle('checked', isNowCompleted);
                if (name) name.classList.toggle('completed', isNowCompleted);
                taskEl.classList.toggle('completed', isNowCompleted);
            } else if (taskEl.classList.contains('week-task-block')) {
                // Timed task block in timeline
                const checkbox = taskEl.querySelector('.task-block-checkbox');
                const name = taskEl.querySelector('.task-block-name');
                if (checkbox) checkbox.classList.toggle('checked', isNowCompleted);
                if (name) name.classList.toggle('completed', isNowCompleted);
                taskEl.classList.toggle('completed', isNowCompleted);
            }

            // XP popup - use different approach for absolutely positioned elements
            const popup = document.createElement('span');
            popup.className = 'xp-popup ' + (isNowCompleted ? 'gain' : 'lose');
            popup.textContent = (isNowCompleted ? '+' : '-') + '10 XP';
            popup.style.position = 'absolute';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.pointerEvents = 'none';
            popup.style.zIndex = '100';
            // DON'T change taskEl.style.position - it breaks absolute positioning!
            taskEl.appendChild(popup);
            setTimeout(() => popup.remove(), 600);

            // Update XP
            totalXp += isNowCompleted ? 10 : -10;
            if (totalXp < 0) totalXp = 0;
            updateLevelDisplay();

            saveData();

            console.log('[DEBUG] toggleWeekTask END - will clear flag in 300ms');
            // Clear flag after a short delay to allow any pending operations
            setTimeout(() => {
                console.log('[DEBUG] Clearing isCompletingWeekTask flag');
                isCompletingWeekTask = false;
            }, 300);
        }

        // Toggle task completion from timeline
        function toggleTimelineTask(taskEl, task) {
            const dateStr = taskEl.dataset.dateStr;
            const dailyId = taskEl.dataset.dailyId;

            const completionKey = dailyId || task.id;
            const completionDate = task.type === 'onetime' ? task.date : dateStr;
            const wasCompleted = isTaskCompletedForDate(completionKey, completionDate);
            const isNowCompleted = !wasCompleted;

            setTaskCompletedForDate(completionKey, completionDate, isNowCompleted);

            // Update UI - handle both untimed tasks (.task-checkbox) and timed task blocks (.task-block-checkbox)
            const checkbox = taskEl.querySelector('.task-checkbox') || taskEl.querySelector('.task-block-checkbox');
            const taskName = taskEl.querySelector('.task-name') || taskEl.querySelector('.task-block-name');
            if (checkbox) checkbox.classList.toggle('checked', isNowCompleted);
            if (taskName) taskName.classList.toggle('completed', isNowCompleted);
            taskEl.classList.toggle('completed', isNowCompleted);

            // Visual feedback
            if (isNowCompleted && checkbox) {
                checkbox.classList.add('completing');
                taskEl.classList.add('completing');
                setTimeout(() => {
                    checkbox.classList.remove('completing');
                    taskEl.classList.remove('completing');
                }, 500);
            }

            // XP popup - position in center of task element
            const popup = document.createElement('span');
            popup.className = 'xp-popup ' + (isNowCompleted ? 'gain' : 'lose');
            popup.textContent = (isNowCompleted ? '+' : '-') + '10 XP';
            popup.style.position = 'absolute';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.pointerEvents = 'none';
            popup.style.zIndex = '100';
            taskEl.appendChild(popup);
            setTimeout(() => popup.remove(), 600);

            // Update XP
            totalXp += isNowCompleted ? 10 : -10;
            if (totalXp < 0) totalXp = 0;
            updateLevelDisplay();

            saveData();
        }

        // Update current time indicator
        function updateCurrentTimeIndicator() {
            // Remove existing indicator
            const existing = dayTimeline.querySelector('.timeline-current-time');
            if (existing) existing.remove();

            const now = new Date();
            const currentDateStr = formatDateForInput(now);
            const viewingDateStr = formatDateForInput(viewingDate);

            // Only show for today
            if (currentDateStr !== viewingDateStr) return;

            // Use 50px hours on mobile, 60px on desktop
            const isMobile = window.innerWidth <= 768;
            const hourHeight = isMobile ? 50 : 60;

            const hours = now.getHours();
            const minutes = now.getMinutes();
            const topPosition = (hours * 60 + minutes) * (hourHeight / 60);

            const indicator = document.createElement('div');
            indicator.className = 'timeline-current-time';
            indicator.style.top = `${topPosition}px`;
            dayTimeline.appendChild(indicator);

            // Scroll to current time on initial render
            if (!dayTimelineContainer._hasScrolled) {
                const scrollTarget = Math.max(0, topPosition - 100);
                dayTimelineContainer.scrollTop = scrollTarget;
                dayTimelineContainer._hasScrolled = true;
            }
        }

        // Update current time indicator every minute
        setInterval(() => {
            if (currentView === 'day') {
                updateCurrentTimeIndicator();
            }
        }, 60000);

        function createTaskElement(task, dateStr, isNewTask = false) {
            const taskItem = document.createElement('div');
            taskItem.className = 'task-item' + (task.completed ? ' completed' : '') + (isNewTask ? ' new-task' : '');
            taskItem.dataset.taskId = task.id;

            // Remove animation class after animation completes
            if (isNewTask) {
                setTimeout(() => taskItem.classList.remove('new-task'), 400);
            }
            taskItem.dataset.dateStr = dateStr;

            if (task.dailyId) {
                taskItem.dataset.dailyId = task.dailyId;
            }
            if (task.pattern) {
                taskItem.dataset.pattern = task.pattern;
            }
            if (task.type) {
                taskItem.dataset.type = task.type;
            }

            const isRepeatingTask = task.type === 'daily' || task.type === 'custom' || task.type === 'every-n-days' || task.type === 'monthly';
            let recurringIndicator = '';
            if (isRepeatingTask) {
                const tooltip = getRecurringTooltip(task);
                recurringIndicator = `<span class="recurring-indicator" data-tooltip="${tooltip}">↻</span>`;
            }

            const checkedClass = task.completed ? ' checked' : '';
            const completedClass = task.completed ? ' completed' : '';
            const categoryColor = getCategoryColor(task.category);
            const timeDisplay = task.time ? `<span class="task-time">${formatTime24Hour(task.time)}</span>` : '';

            taskItem.innerHTML = `
                <div class="task-checkbox${checkedClass}"></div>
                ${recurringIndicator}
                <div class="category-indicator" style="background: ${categoryColor};"></div>
                <div class="task-content">
                    ${timeDisplay}
                    <span class="task-name${completedClass}">${escapeHtml(task.name)}</span>
                </div>
                <button type="button" class="delete-button">&times;</button>
            `;

            // Event listeners - checkbox only toggles completion
            const checkbox = taskItem.querySelector('.task-checkbox');
            checkbox.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleTask(taskItem);
            });

            const deleteBtn = taskItem.querySelector('.delete-button');
            deleteBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                handleDeleteTask(taskItem);
            });

            // Task name click handler - opens notes modal for all tasks
            const taskNameEl = taskItem.querySelector('.task-name');
            taskNameEl.addEventListener('click', function(e) {
                e.stopPropagation();
                openNotesModal(task.id);
            });

            return taskItem;
        }

        function toggleTask(taskItem) {
            const taskId = taskItem.dataset.taskId;
            const dateStr = taskItem.dataset.dateStr;
            const dailyId = taskItem.dataset.dailyId;

            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            const completionKey = dailyId || taskId;
            const completionDate = task.type === 'onetime' ? task.date : dateStr;
            const wasCompleted = isTaskCompletedForDate(completionKey, completionDate);
            const isNowCompleted = !wasCompleted;

            setTaskCompletedForDate(completionKey, completionDate, isNowCompleted);

            // Update UI
            const checkbox = taskItem.querySelector('.task-checkbox');
            const taskName = taskItem.querySelector('.task-name');
            checkbox.classList.toggle('checked', isNowCompleted);
            taskName.classList.toggle('completed', isNowCompleted);
            taskItem.classList.toggle('completed', isNowCompleted);

            // Enhanced visual feedback on completion
            if (isNowCompleted) {
                // Add completing animations
                checkbox.classList.add('completing');
                taskItem.classList.add('completing');

                // Remove animation classes after animation completes
                setTimeout(() => {
                    checkbox.classList.remove('completing');
                    taskItem.classList.remove('completing');
                }, 500);
            }

            // XP popup (positioned near checkbox)
            const popup = document.createElement('span');
            popup.className = 'xp-popup ' + (isNowCompleted ? 'gain' : 'lose');
            popup.textContent = (isNowCompleted ? '+' : '-') + '10 XP';
            checkbox.appendChild(popup);
            setTimeout(() => popup.remove(), 600);

            // Update XP
            totalXp += isNowCompleted ? 10 : -10;
            if (totalXp < 0) totalXp = 0;
            updateLevelDisplay();

            saveData();

            // Check achievements when completing a task
            if (isNowCompleted) {
                checkAchievements();
            }
        }

        function handleDeleteTask(taskItem) {
            const taskId = taskItem.dataset.taskId;
            const dailyId = taskItem.dataset.dailyId;
            const dateStr = taskItem.dataset.dateStr;
            const type = taskItem.dataset.type;

            const isRepeating = dailyId || type === 'daily' || type === 'custom' || type === 'every-n-days' || type === 'monthly';

            if (isRepeating) {
                // Recurring task - show modal
                pendingDeleteTask = taskItem;
                pendingDeleteContext = { taskId, dailyId, dateStr, type };

                const task = tasks.find(t => t.id === taskId);
                const label = getRepeatLabel(task);

                modalTitle.textContent = 'Delete Repeating Task';
                modalText.textContent = `This task repeats (${label}). How would you like to delete it?`;
                deleteModal.classList.add('active');
            } else {
                // One-time task - delete directly
                deleteTaskCompletely(taskId);
            }
        }

        function deleteThisDay() {
            if (!pendingDeleteContext) return;

            const { taskId, dailyId, dateStr } = pendingDeleteContext;
            const completionKey = dailyId || taskId;
            const task = tasks.find(t => t.id === taskId);
            const taskName = task ? task.name : 'Task';

            // Save completion state for undo
            const wasCompleted = isTaskCompletedForDate(completionKey, dateStr);

            // Remove XP if completed for this date
            if (wasCompleted) {
                totalXp -= 10;
                if (totalXp < 0) totalXp = 0;
            }

            // Remove completion for this date
            if (taskCompletions[completionKey]) {
                delete taskCompletions[completionKey][dateStr];
            }

            // Verify XP by recalculating from remaining completions + achievements
            const calculatedXp = recalculateXpFromCompletions() + calculateAchievementXp();
            if (totalXp !== calculatedXp) {
                totalXp = calculatedXp;
            }

            updateLevelDisplay();
            saveData();

            // In Month view, update only the affected date section to avoid scroll reset
            if (currentView === 'month' && dateStr) {
                // Update both views (mobile list and desktop grid)
                const listUpdated = updateMonthDateSection(dateStr);
                const gridUpdated = updateMonthGridDateCell(dateStr);
                // Fall back to full render if neither worked
                if (!listUpdated && !gridUpdated) {
                    renderCurrentView();
                }
            } else {
                renderCurrentView();
            }
            closeDeleteModal();

            // Show undo toast
            showUndoToast('Task deleted', () => {
                // Restore completion state if it was completed
                if (wasCompleted) {
                    setTaskCompletedForDate(completionKey, dateStr, true);
                }
                totalXp = recalculateXpFromCompletions() + calculateAchievementXp();
                updateLevelDisplay();
                saveData();
                renderCurrentView();
            });
        }

        function deleteAllDays() {
            if (!pendingDeleteContext) return;

            const { taskId, dailyId } = pendingDeleteContext;
            const completionKey = dailyId || taskId;
            const preview = pendingDeleteTask;

            // For Month view, save scroll position before deletion
            const isMonthView = currentView === 'month';
            const savedScrollY = isMonthView ? window.scrollY : 0;

            // Close modal first
            closeDeleteModal();

            // Animate if in Month grid view and we have the preview element
            if (isMonthView && preview && preview.classList.contains('month-task-preview')) {
                preview.classList.add('removing');

                setTimeout(() => {
                    // Skip render in deleteTaskCompletely - we'll handle it
                    deleteTaskCompletely(taskId, completionKey, true);

                    // Render with scroll position preservation
                    renderCurrentView();
                    requestAnimationFrame(() => {
                        window.scrollTo(0, savedScrollY);
                    });
                }, 200);
            } else {
                // Non-Month view or no preview - delete immediately
                deleteTaskCompletely(taskId, completionKey, isMonthView);

                if (isMonthView) {
                    renderCurrentView();
                    requestAnimationFrame(() => {
                        window.scrollTo(0, savedScrollY);
                    });
                }
            }
        }

        function deleteTaskCompletely(taskId, completionKey = null, skipRender = false) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            // Save task data for undo
            const deletedTask = { ...task };
            const taskName = task.name;

            // Save task date for one-time tasks before deletion (for targeted Month view update)
            const isOneTimeTask = task.type === 'onetime';
            const taskDate = isOneTimeTask ? task.date : null;

            const key = completionKey || task.dailyId || taskId;

            // Save completions for undo
            const savedCompletions = {};
            if (taskCompletions[key]) {
                savedCompletions[key] = { ...taskCompletions[key] };
            }
            if (key !== taskId && taskCompletions[taskId]) {
                savedCompletions[taskId] = { ...taskCompletions[taskId] };
            }

            // Remove XP for all completed dates
            if (taskCompletions[key]) {
                const completedCount = Object.values(taskCompletions[key]).filter(v => v === true).length;
                if (completedCount > 0) {
                    totalXp -= completedCount * 10;
                    if (totalXp < 0) totalXp = 0;
                }
                delete taskCompletions[key];
            }

            // Also check if task ID has separate completions (for edge cases)
            if (key !== taskId && taskCompletions[taskId]) {
                const completedCount = Object.values(taskCompletions[taskId]).filter(v => v === true).length;
                if (completedCount > 0) {
                    totalXp -= completedCount * 10;
                    if (totalXp < 0) totalXp = 0;
                }
                delete taskCompletions[taskId];
            }

            // Remove task from list
            tasks = tasks.filter(t => t.id !== taskId);

            // Verify XP by recalculating from remaining completions + achievements
            const calculatedXp = recalculateXpFromCompletions() + calculateAchievementXp();
            if (totalXp !== calculatedXp) {
                totalXp = calculatedXp;
            }

            updateLevelDisplay();
            saveData();

            // Skip render if caller will handle it (e.g., deleteAllDays with scroll preservation)
            if (!skipRender) {
                // In Month view, use targeted update for one-time tasks to avoid scroll reset
                if (currentView === 'month' && isOneTimeTask && taskDate) {
                    // Update both views (mobile list and desktop grid)
                    const listUpdated = updateMonthDateSection(taskDate);
                    const gridUpdated = updateMonthGridDateCell(taskDate);
                    // Fall back to full render if neither worked
                    if (!listUpdated && !gridUpdated) {
                        renderCurrentView();
                    }
                } else {
                    renderCurrentView();
                }
            }

            // Close bottom sheet if open
            if (bottomSheet.classList.contains('open')) {
                renderBottomSheetTasks();
            }

            // Show undo toast
            showUndoToast('Task deleted', () => {
                // Restore task
                tasks.push(deletedTask);
                // Restore completions
                for (const compKey in savedCompletions) {
                    taskCompletions[compKey] = savedCompletions[compKey];
                }
                // Recalculate XP
                totalXp = recalculateXpFromCompletions() + calculateAchievementXp();
                updateLevelDisplay();
                saveData();
                renderCurrentView();
            });
        }

        function closeDeleteModal() {
            deleteModal.classList.remove('active');
            pendingDeleteTask = null;
            pendingDeleteContext = null;
        }

        // Toggle task completion in month grid view
        function toggleGridTask(preview) {
            const taskId = preview.dataset.taskId;
            const dateStr = preview.dataset.dateStr;
            const dailyId = preview.dataset.dailyId;

            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            const completionKey = dailyId || taskId;
            const completionDate = task.type === 'onetime' ? task.date : dateStr;
            const wasCompleted = isTaskCompletedForDate(completionKey, completionDate);
            const isNowCompleted = !wasCompleted;

            setTaskCompletedForDate(completionKey, completionDate, isNowCompleted);

            // Update UI
            const checkbox = preview.querySelector('.month-task-checkbox');
            const text = preview.querySelector('.month-task-text');
            checkbox.classList.toggle('checked', isNowCompleted);
            preview.classList.toggle('completed', isNowCompleted);

            // Update XP
            totalXp += isNowCompleted ? 10 : -10;
            if (totalXp < 0) totalXp = 0;
            updateLevelDisplay();

            saveData();

            // Check achievements when completing a task
            if (isNowCompleted) {
                checkAchievements();
            }
        }

        // Handle delete for grid task preview
        function handleGridTaskDelete(preview) {
            const taskId = preview.dataset.taskId;
            const dailyId = preview.dataset.dailyId;
            const dateStr = preview.dataset.dateStr;
            const type = preview.dataset.type;

            if (dailyId || type === 'daily' || type === 'custom') {
                // Recurring task - show modal
                pendingDeleteTask = preview;
                pendingDeleteContext = { taskId, dailyId, dateStr, type };

                const task = tasks.find(t => t.id === taskId);
                const label = getPatternLabel(task?.pattern);

                modalTitle.textContent = 'Delete Repeating Task';
                modalText.textContent = `This task repeats (${label}). How would you like to delete it?`;
                deleteModal.classList.add('active');
            } else {
                // One-time task - animate then delete
                animateGridTaskRemoval(preview, () => {
                    deleteTaskCompletely(taskId);
                });
            }
        }

        // Animate task removal in Month grid view
        function animateGridTaskRemoval(preview, callback) {
            // Add removing class to trigger animation
            preview.classList.add('removing');

            // Wait for animation to complete, then execute callback
            setTimeout(() => {
                if (callback) callback();
            }, 200);
        }

        // Week View - 7-column timeline scheduler
        function renderWeekView() {
            // Prevent re-render during task completion (prevents position jumping)
            if (isCompletingWeekTask) {
                console.log('[DEBUG] renderWeekView() BLOCKED - isCompletingWeekTask =', isCompletingWeekTask);
                return;
            }

            console.log('[DEBUG] renderWeekView() EXECUTING');

            // Clear previous content
            if (weekDaysGrid) weekDaysGrid.innerHTML = '';
            if (weekHourMarkers) weekHourMarkers.innerHTML = '';
            weekUntimedDays.innerHTML = '';

            const weekDates = getWeekDates(viewingDate);
            const today = new Date();
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();

            const isMobile = window.innerWidth < 768;
            const hourHeight = isMobile ? 50 : 60;
            let todayColumnIndex = -1;

            // ===== RENDER DAY HEADERS (mobile and desktop use same structure) =====
            if (weekDayHeaders) {
                // Keep the corner cell, clear day headers
                const existingCorner = weekDayHeaders.querySelector('.week-header-corner');
                weekDayHeaders.innerHTML = '';

                // Add corner cell
                const corner = document.createElement('div');
                corner.className = 'week-header-corner';
                weekDayHeaders.appendChild(corner);

                // Add day header cells
                weekDates.forEach((date, index) => {
                    const isToday = isSameDay(date, today);
                    if (isToday) todayColumnIndex = index;

                    // Check if weekend (0 = Sunday, 6 = Saturday)
                    const dayOfWeek = date.getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

                    const cell = document.createElement('div');
                    cell.className = 'week-day-header-cell' +
                        (isToday ? ' today' : '') +
                        (isWeekend ? ' weekend' : '');

                    const name = document.createElement('div');
                    name.className = 'week-day-header-name';
                    name.textContent = dayAbbrev[index];

                    const num = document.createElement('div');
                    num.className = 'week-day-header-num';
                    num.textContent = date.getDate();

                    cell.appendChild(name);
                    cell.appendChild(num);
                    weekDayHeaders.appendChild(cell);
                });
            }

            // ===== RENDER HOUR MARKERS (mobile and desktop use same structure) =====
            if (weekHourMarkers) {
                for (let hour = 0; hour < 24; hour++) {
                    const marker = document.createElement('div');
                    // Business hours: 9 AM to 5 PM (9-17)
                    const isBusinessHour = hour >= 9 && hour <= 17;
                    marker.className = 'week-hour-marker' + (isBusinessHour ? ' business-hours' : '');
                    marker.textContent = hour.toString().padStart(2, '0') + ':00';
                    weekHourMarkers.appendChild(marker);
                }
            }

            // ===== COLLECT UNTIMED TASKS =====
            let totalUntimedCount = 0;
            const weekUntimedData = [];

            weekDates.forEach((date, index) => {
                const isToday = isSameDay(date, today);
                const dateStr = formatDateForInput(date);
                const tasksForDay = getTasksForDate(date);
                const untimedTasks = tasksForDay.filter(t => !t.time);

                totalUntimedCount += untimedTasks.length;
                weekUntimedData.push({
                    date,
                    dateStr,
                    isToday,
                    dayIndex: index,
                    untimedTasks
                });
            });

            // ===== RENDER UNTIMED TASKS SECTION =====
            weekUntimedCount.textContent = totalUntimedCount;
            if (totalUntimedCount > 0) {
                weekUntimedContainer.classList.add('has-tasks');

                weekUntimedData.forEach(({ date, dateStr, isToday, dayIndex, untimedTasks }) => {
                    const dayGroup = document.createElement('div');
                    dayGroup.className = 'week-untimed-day' + (isToday ? ' today' : '') + (untimedTasks.length === 0 ? ' empty' : '');

                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'week-untimed-day-header';
                    dayHeader.innerHTML = `${dayAbbrev[dayIndex]} <span class="week-untimed-day-count">(${untimedTasks.length})</span>`;
                    dayGroup.appendChild(dayHeader);

                    untimedTasks.forEach(task => {
                        const isCompleted = isTaskCompletedForDate(task.id, dateStr);
                        const categoryColor = getCategoryColor(task.category);

                        const taskEl = document.createElement('div');
                        taskEl.className = 'week-untimed-item' + (isCompleted ? ' completed' : '');
                        taskEl.dataset.taskId = task.id;
                        taskEl.dataset.date = dateStr;
                        taskEl.innerHTML = `
                            <div class="item-checkbox ${isCompleted ? 'checked' : ''}"></div>
                            <div class="item-dot" style="background: ${categoryColor}"></div>
                            <div class="item-name">${task.name}</div>
                        `;

                        taskEl.addEventListener('click', (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            toggleWeekTask(task.id, dateStr, taskEl);
                        });

                        dayGroup.appendChild(taskEl);
                    });

                    weekUntimedDays.appendChild(dayGroup);
                });
            } else {
                weekUntimedContainer.classList.remove('has-tasks');
            }

            // ===== RENDER DAY COLUMNS (mobile and desktop use same structure) =====
            if (weekDaysGrid) {
                // Render into weekDaysGrid (same structure for mobile and desktop)
                weekDates.forEach((date, index) => {
                    const isToday = isSameDay(date, today);
                    if (isToday) todayColumnIndex = index;

                    const dateStr = formatDateForInput(date);
                    const tasksForDay = getTasksForDate(date);
                    const timedTasks = tasksForDay.filter(t => t.time);

                    // Check if weekend (0 = Sunday, 6 = Saturday)
                    const dayOfWeek = date.getDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

                    // Create day column
                    const dayCol = document.createElement('div');
                    dayCol.className = 'week-day-column' +
                        (isToday ? ' today' : '') +
                        (isWeekend ? ' weekend' : '');
                    dayCol.dataset.date = dateStr;

                    // Calculate overlaps for this day's timed tasks
                    const overlapInfo = calculateTaskOverlaps(timedTasks);

                    // Render timed task blocks
                    timedTasks.forEach(task => {
                        const taskOverlapData = overlapInfo.get(task.id);
                        const taskBlock = createWeekTaskBlock(task, dateStr, taskOverlapData, hourHeight);
                        dayCol.appendChild(taskBlock);
                    });

                    // Current time indicator (only for today)
                    if (isToday) {
                        const currentTimePosition = (currentHour * 60 + currentMinute) * (hourHeight / 60);
                        const currentTimeIndicator = document.createElement('div');
                        currentTimeIndicator.className = 'week-current-time';
                        currentTimeIndicator.style.top = `${currentTimePosition}px`;
                        dayCol.appendChild(currentTimeIndicator);
                    }

                    // Click on timeline to add task at that time
                    dayCol.addEventListener('click', (e) => {
                        if (e.target.closest('.week-task-block')) return;

                        const rect = dayCol.getBoundingClientRect();
                        const scrollTop = weekScrollContainer ? weekScrollContainer.scrollTop : 0;
                        const headerHeight = 48; // Day headers height
                        const clickY = e.clientY - rect.top;
                        const hour = Math.floor(clickY / hourHeight);
                        const minuteRatio = (clickY % hourHeight) / hourHeight;
                        const minutes = Math.floor(minuteRatio * 60 / 15) * 15;

                        if (hour >= 0 && hour < 24) {
                            const timeStr = `${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                            openCreateTaskModal(dateStr, timeStr);
                        }
                    });

                    weekDaysGrid.appendChild(dayCol);
                });

                // Auto-scroll to today's column and current time
                setTimeout(() => {
                    if (weekScrollContainer && weekDaysGrid) {
                        // Get actual column width dynamically (since we use 1fr)
                        const dayColumns = weekDaysGrid.querySelectorAll('.week-day-column');
                        // Hour markers width: 50px on mobile, 60px on desktop
                        const hourMarkersWidth = isMobile ? 50 : 60;

                        // Horizontal scroll to center today's column
                        if (todayColumnIndex >= 0 && dayColumns.length > 0) {
                            const columnWidth = dayColumns[0].offsetWidth;
                            const wrapperWidth = weekScrollContainer.clientWidth;
                            const targetScrollX = Math.max(0, hourMarkersWidth + (todayColumnIndex * columnWidth) - (wrapperWidth / 2) + (columnWidth / 2));
                            weekScrollContainer.scrollLeft = targetScrollX;
                        }

                        // Vertical scroll to current time
                        const targetHour = currentHour < 6 ? 8 : currentHour;
                        const headerHeight = isMobile ? 60 : 70;
                        const targetScrollY = Math.max(0, (targetHour * hourHeight) + headerHeight - 60);
                        weekScrollContainer.scrollTop = targetScrollY;
                    }
                }, 100);
            }
        }

        // Desktop Week View rendering (backward compatible)
        function renderWeekViewDesktop(weekDates, today, currentHour, currentMinute, hourHeight) {
            // For desktop, we'll create the old structure if needed
            // Desktop uses different selectors, this is a simplified version
            const weekTimelineGrid = document.getElementById('weekTimelineGrid');
            if (!weekTimelineGrid) return;

            weekTimelineGrid.innerHTML = '';

            weekDates.forEach((date, index) => {
                const isToday = isSameDay(date, today);
                const dateStr = formatDateForInput(date);
                const tasksForDay = getTasksForDate(date);
                const timedTasks = tasksForDay.filter(t => t.time);

                const dayCol = document.createElement('div');
                dayCol.className = 'week-day-column' + (isToday ? ' today' : '');
                dayCol.dataset.date = dateStr;

                const header = document.createElement('div');
                header.className = 'week-column-header';
                header.innerHTML = `
                    <div class="week-column-day-name">${dayAbbrev[index]}</div>
                    <div class="week-column-day-num">${date.getDate()}</div>
                `;
                dayCol.appendChild(header);

                const timelineScroll = document.createElement('div');
                timelineScroll.className = 'week-column-timeline';

                const hoursContainer = document.createElement('div');
                hoursContainer.className = 'week-column-hours';
                hoursContainer.style.height = `${24 * hourHeight}px`;

                for (let hour = 0; hour < 24; hour++) {
                    const hourRow = document.createElement('div');
                    hourRow.className = 'week-hour-row';
                    hourRow.style.top = `${hour * hourHeight}px`;
                    hourRow.style.height = `${hourHeight}px`;

                    if (hour % 2 === 0) {
                        const hourLabel = document.createElement('span');
                        hourLabel.className = 'week-hour-label';
                        hourLabel.textContent = `${hour.toString().padStart(2, '0')}`;
                        hourRow.appendChild(hourLabel);
                    }

                    hoursContainer.appendChild(hourRow);
                }

                const tasksLayer = document.createElement('div');
                tasksLayer.className = 'week-tasks-layer';

                const overlapInfo = calculateTaskOverlaps(timedTasks);

                timedTasks.forEach(task => {
                    const taskOverlapData = overlapInfo.get(task.id);
                    const taskBlock = createWeekTaskBlock(task, dateStr, taskOverlapData, hourHeight);
                    tasksLayer.appendChild(taskBlock);
                });

                hoursContainer.appendChild(tasksLayer);

                if (isToday) {
                    const currentTimePosition = (currentHour * 60 + currentMinute) * (hourHeight / 60);
                    const currentTimeIndicator = document.createElement('div');
                    currentTimeIndicator.className = 'week-current-time';
                    currentTimeIndicator.style.top = `${currentTimePosition}px`;
                    hoursContainer.appendChild(currentTimeIndicator);
                }

                hoursContainer.addEventListener('click', (e) => {
                    if (e.target.closest('.week-task-block')) return;
                    const rect = hoursContainer.getBoundingClientRect();
                    const clickY = e.clientY - rect.top + timelineScroll.scrollTop;
                    const hour = Math.floor(clickY / hourHeight);
                    const minuteRatio = (clickY % hourHeight) / hourHeight;
                    const minutes = Math.floor(minuteRatio * 60 / 15) * 15;

                    if (hour >= 0 && hour < 24) {
                        const timeStr = `${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        openCreateTaskModal(dateStr, timeStr);
                    }
                });

                timelineScroll.appendChild(hoursContainer);
                dayCol.appendChild(timelineScroll);
                weekTimelineGrid.appendChild(dayCol);
            });

            // Desktop scroll sync - ONLY on desktop to avoid mobile jerking
            if (window.innerWidth >= 769) {
                const allTimelines = weekTimelineGrid.querySelectorAll('.week-column-timeline');
                let isScrolling = false;

                allTimelines.forEach(timeline => {
                    timeline.addEventListener('scroll', () => {
                        if (isScrolling) return;
                        isScrolling = true;

                        const scrollTop = timeline.scrollTop;
                        allTimelines.forEach(other => {
                            if (other !== timeline) {
                                other.scrollTop = scrollTop;
                            }
                        });

                        requestAnimationFrame(() => {
                            isScrolling = false;
                        });
                    });
                });
            }

            const todayColumn = weekTimelineGrid.querySelector('.week-day-column.today .week-column-timeline');
            if (todayColumn) {
                setTimeout(() => {
                    const currentTimePosition = currentHour * hourHeight + currentMinute * (hourHeight / 60);
                    todayColumn.scrollTop = Math.max(0, currentTimePosition - 60);
                }, 50);
            }
        }

        // Create task block for week view (compact version)
        function createWeekTaskBlock(task, dateStr, overlapData = null, hourHeight = 60) {
            const isCompleted = isTaskCompletedForDate(task.id, dateStr);
            const categoryColor = getCategoryColor(task.category);

            // Parse time and calculate position using hourHeight
            const [hours, minutes] = task.time.split(':').map(Number);
            const topPosition = (hours * 60 + minutes) * (hourHeight / 60);

            // Calculate height based on duration, scaled to hourHeight
            const duration = task.duration || 30;
            const scaledHeight = duration * (hourHeight / 60);
            const blockHeight = Math.max(scaledHeight, hourHeight < 60 ? 16 : 20); // Smaller minimum on mobile

            const taskBlock = document.createElement('div');
            taskBlock.dataset.taskId = task.id;
            taskBlock.dataset.date = dateStr;

            // Position
            taskBlock.style.top = `${topPosition}px`;
            taskBlock.style.height = `${blockHeight}px`;

            // Handle overlap positioning (use correct property names)
            const hasOverlap = overlapData && overlapData.hasOverlap;
            const totalInGroup = overlapData ? overlapData.totalInGroup : 1;
            const positionInGroup = overlapData ? overlapData.positionInGroup : 0;

            let widthPercent = 100;
            let leftPercent = 0;

            if (hasOverlap && totalInGroup > 1) {
                // Calculate width and position based on number of overlapping tasks
                if (totalInGroup === 2) {
                    // 2 tasks: 48% width each, 2% gap
                    widthPercent = 48;
                    leftPercent = positionInGroup * 50;
                } else if (totalInGroup === 3) {
                    // 3 tasks: 32% width each, 2% gaps
                    widthPercent = 32;
                    leftPercent = positionInGroup * 34;
                } else {
                    // 4+ tasks: equal distribution
                    widthPercent = Math.floor(96 / totalInGroup);
                    leftPercent = positionInGroup * (100 / totalInGroup);
                }
            }

            taskBlock.style.width = `${widthPercent}%`;
            taskBlock.style.left = `${leftPercent}%`;

            // Set class with overlap state
            taskBlock.className = 'week-task-block' +
                (isCompleted ? ' completed' : '') +
                (hasOverlap ? ' overlapping' : '');

            // Category color background
            taskBlock.style.background = hexToRgba(categoryColor, 0.25);
            taskBlock.style.borderLeftColor = categoryColor;

            // Content - compact for week view
            const timeFormatted = formatTime24Hour(task.time);

            // Build warning icon for overlapping tasks
            let overlapWarning = '';
            if (hasOverlap) {
                overlapWarning = '<span class="week-overlap-warning">⚠️</span>';
            }

            // Build content (no checkbox - use click/long press interaction)
            if (blockHeight >= 30) {
                taskBlock.innerHTML = `
                    ${overlapWarning}
                    <div class="task-block-name">${escapeHtml(task.name)}</div>
                    <div class="task-block-time">${timeFormatted}</div>
                `;
            } else {
                taskBlock.innerHTML = `
                    ${overlapWarning}
                    <div class="task-block-name">${escapeHtml(task.name)}</div>
                `;
            }

            // Interaction: Quick click = toggle completion, Long press = view details
            let longPressTimer = null;
            let isLongPress = false;

            // Mouse events for desktop
            taskBlock.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click
                isLongPress = false;
                taskBlock.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskBlock.classList.remove('pressing');
                    openTaskDetailModal(task.id, dateStr);
                }, 500);
            });

            taskBlock.addEventListener('mouseup', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskBlock.addEventListener('mouseleave', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskBlock.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Only toggle if it wasn't a long press
                if (!isLongPress) {
                    toggleWeekTask(task.id, dateStr, taskBlock);
                }
                isLongPress = false;
            });

            // Touch events for mobile
            taskBlock.addEventListener('touchstart', (e) => {
                isLongPress = false;
                taskBlock.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskBlock.classList.remove('pressing');
                    openTaskDetailModal(task.id, dateStr);
                }, 500);
            }, { passive: true });

            taskBlock.addEventListener('touchend', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                // If it wasn't a long press, toggle completion
                if (!isLongPress) {
                    e.preventDefault();
                    toggleWeekTask(task.id, dateStr, taskBlock);
                }
            });

            taskBlock.addEventListener('touchmove', (e) => {
                // Cancel long press if user moves finger (scrolling)
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: true });

            taskBlock.addEventListener('touchcancel', (e) => {
                taskBlock.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            return taskBlock;
        }

        // Navigate to previous/next week
        function navigateWeek(delta) {
            console.log('[Week Nav] navigateWeek called with delta:', delta);
            console.log('[Week Nav] Current viewingDate before:', viewingDate.toISOString());

            // Create a new Date object to avoid mutation issues
            const newDate = new Date(viewingDate);
            newDate.setDate(newDate.getDate() + (delta * 7));
            viewingDate = newDate;

            viewingMonth = viewingDate.getMonth();
            viewingYear = viewingDate.getFullYear();

            console.log('[Week Nav] New viewingDate after:', viewingDate.toISOString());

            updateDateDisplay();
            renderWeekView();
        }

        // Navigate to current week and scroll to today
        function goToCurrentWeek() {
            console.log('[Week Nav] goToCurrentWeek called');
            viewingDate = new Date();
            viewingMonth = viewingDate.getMonth();
            viewingYear = viewingDate.getFullYear();
            updateDateDisplay();
            renderWeekView();

            // Scroll to today's column (works on both mobile and desktop now)
            setTimeout(() => {
                const today = new Date();
                const weekDates = getWeekDates(viewingDate);
                const todayIndex = weekDates.findIndex(d => isSameDay(d, today));
                const isMobile = window.innerWidth < 768;
                const hourHeight = isMobile ? 50 : 60;
                const hourMarkersWidth = isMobile ? 50 : 60;
                const headerHeight = isMobile ? 60 : 70;

                if (todayIndex >= 0 && weekScrollContainer && weekDaysGrid) {
                    // Get actual column width dynamically
                    const dayColumns = weekDaysGrid.querySelectorAll('.week-day-column');
                    const columnWidth = dayColumns.length > 0 ? dayColumns[0].offsetWidth : 100;
                    const wrapperWidth = weekScrollContainer.clientWidth;
                    const targetScrollX = Math.max(0, hourMarkersWidth + (todayIndex * columnWidth) - (wrapperWidth / 2) + (columnWidth / 2));
                    weekScrollContainer.scrollTo({ left: targetScrollX, behavior: 'smooth' });

                    // Also scroll to current time vertically
                    const currentHour = new Date().getHours();
                    const targetHour = currentHour < 6 ? 8 : currentHour;
                    const targetScrollY = Math.max(0, (targetHour * hourHeight) + headerHeight - 60);
                    weekScrollContainer.scrollTo({ top: targetScrollY, behavior: 'smooth' });
                }
            }, 150);
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Month View
        function renderMonthView() {
            // Render both views (CSS handles which one is visible)
            renderMonthListView();
            renderMonthGridView();
        }

        // Track loaded month range for infinite scroll
        let loadedMonthStart = null;
        let loadedMonthEnd = null;
        let monthScrollObserver = null;
        let isLoadingMonths = false;
        let isInitialMonthRender = true; // Prevent auto-scroll on initial render
        let lastLoadTime = 0; // Debounce rapid scroll loads
        const LOAD_DEBOUNCE_MS = 150; // Minimum time between loads

        // Mobile: Vertical scrollable list - Compact with infinite scroll
        function renderMonthListView() {
            monthList.innerHTML = '';

            // Mark as initial render - prevents auto-scroll loading
            isInitialMonthRender = true;

            // Initialize with 3 months: prev, current, next
            loadedMonthStart = { month: viewingMonth - 1, year: viewingYear };
            loadedMonthEnd = { month: viewingMonth + 1, year: viewingYear };

            // Normalize months
            if (loadedMonthStart.month < 0) {
                loadedMonthStart.month = 11;
                loadedMonthStart.year--;
            }
            if (loadedMonthEnd.month > 11) {
                loadedMonthEnd.month = 0;
                loadedMonthEnd.year++;
            }

            // Render all 3 months
            renderMonthBlock(loadedMonthStart.year, loadedMonthStart.month);
            renderMonthBlock(viewingYear, viewingMonth, true);
            renderMonthBlock(loadedMonthEnd.year, loadedMonthEnd.month);

            // Scroll to current month BEFORE setting up observers
            const currentMonthHeader = monthList.querySelector(`.month-header-separator[data-month="${viewingMonth}"][data-year="${viewingYear}"]`);
            if (currentMonthHeader) {
                currentMonthHeader.scrollIntoView({ behavior: 'auto', block: 'start' });
            }

            // Set up scroll observer AFTER initial scroll, with delay to prevent auto-triggering
            setTimeout(() => {
                setupMonthScrollObserver();
                // Allow infinite scroll after a short delay
                setTimeout(() => {
                    isInitialMonthRender = false;
                }, 500);
            }, 100);
        }

        // Render a single month block with header, dates, and week separators
        function renderMonthBlock(year, month, isCurrent = false) {
            const today = new Date();
            const isCurrentMonth = today.getMonth() === month && today.getFullYear() === year;

            // Month header separator
            const monthHeader = document.createElement('div');
            monthHeader.className = 'month-header-separator' + (isCurrent ? ' current' : '');
            monthHeader.dataset.month = month;
            monthHeader.dataset.year = year;

            const headerTitle = document.createElement('div');
            headerTitle.className = 'month-header-title';
            headerTitle.textContent = `${monthNames[month]} ${year}`;
            monthHeader.appendChild(headerTitle);

            monthList.appendChild(monthHeader);

            // Month block container
            const monthBlock = document.createElement('div');
            monthBlock.className = 'month-block';
            monthBlock.dataset.month = month;
            monthBlock.dataset.year = year;

            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();

            let lastWeekNum = -1;

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const isToday = isCurrentMonth && day === today.getDate();
                const dateStr = formatDateForInput(date);
                const weekdayIndex = getWeekdayFromDate(date);
                const tasksForDay = getTasksForDate(date);
                const hasNoTasks = tasksForDay.length === 0;

                // Calculate week number (week starts on Monday)
                const weekNum = Math.floor((day + getWeekdayFromDate(new Date(year, month, 1)) - 1) / 7);

                // Add week separator
                if (lastWeekNum >= 0 && weekNum > lastWeekNum) {
                    const weekSep = document.createElement('div');
                    weekSep.className = 'week-separator';
                    monthBlock.appendChild(weekSep);
                }
                lastWeekNum = weekNum;

                const section = createDateSection(date, dateStr, day, weekdayIndex, tasksForDay, isToday, hasNoTasks);
                monthBlock.appendChild(section);
            }

            monthList.appendChild(monthBlock);
        }

        // Create a single date section element
        function createDateSection(date, dateStr, day, weekdayIndex, tasksForDay, isToday, hasNoTasks) {
            const section = document.createElement('div');
            section.className = 'month-date-section' + (isToday ? ' today' : '') + (hasNoTasks ? ' empty-section' : '');
            section.dataset.date = dateStr;

            // Compact Header
            const header = document.createElement('div');
            header.className = 'month-date-header';

            const title = document.createElement('div');
            title.className = 'month-date-title';
            title.innerHTML = `
                <span class="month-date-num">${day}</span>
                <span class="month-date-day">${dayAbbrev[weekdayIndex]}</span>
            `;

            header.appendChild(title);

            // For today, show badge
            if (isToday) {
                const badge = document.createElement('span');
                badge.className = 'month-date-badge';
                badge.textContent = 'Today';
                header.appendChild(badge);
            }

            // For empty dates, show "No tasks" label inline
            if (hasNoTasks && !isToday) {
                const emptyLabel = document.createElement('span');
                emptyLabel.className = 'month-empty-label';
                emptyLabel.textContent = 'No tasks';
                header.appendChild(emptyLabel);
            }

            // Task count badge for sections with tasks
            if (!hasNoTasks) {
                const countBadge = document.createElement('span');
                countBadge.className = 'month-task-count';
                countBadge.textContent = `${tasksForDay.length} task${tasksForDay.length > 1 ? 's' : ''}`;
                header.appendChild(countBadge);
            }

            // Add indicator (shows on hover)
            const addIndicator = document.createElement('span');
            addIndicator.className = 'month-add-indicator';
            addIndicator.textContent = '+';
            header.appendChild(addIndicator);

            section.appendChild(header);

            // Add tasks container if there are tasks
            if (!hasNoTasks) {
                const tasksContainer = document.createElement('div');
                tasksContainer.className = 'month-date-tasks';

                const tasksList = document.createElement('div');
                tasksList.className = 'day-tasks';

                tasksForDay.forEach(task => {
                    const taskEl = createTaskElement(task, dateStr);
                    tasksList.appendChild(taskEl);
                });

                tasksContainer.appendChild(tasksList);
                section.appendChild(tasksContainer);
            }

            // Make entire section clickable for adding tasks
            // But don't trigger when clicking on checkboxes, delete buttons, or task items
            section.addEventListener('click', (e) => {
                // Check if click was on an interactive element within a task
                const taskItem = e.target.closest('.task-item');
                if (taskItem) {
                    // Let the task item handle its own click events
                    return;
                }
                // Open task creation modal with this date pre-selected
                openCreateTaskModal(dateStr);
            });

            return section;
        }

        // Set up intersection observer for infinite scroll and header updates
        function setupMonthScrollObserver() {
            // Properly disconnect existing observers
            if (monthScrollObserver) {
                if (monthScrollObserver.header) monthScrollObserver.header.disconnect();
                if (monthScrollObserver.load) monthScrollObserver.load.disconnect();
            }

            // Observer for updating the header date display
            const headerObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                        const month = parseInt(entry.target.dataset.month);
                        const year = parseInt(entry.target.dataset.year);
                        if (!isNaN(month) && !isNaN(year)) {
                            viewingMonth = month;
                            viewingYear = year;
                            updateDateDisplay();
                        }
                    }
                });
            }, {
                root: null,
                threshold: 0.5,
                rootMargin: '-100px 0px -50% 0px'
            });

            // Observe all month headers
            monthList.querySelectorAll('.month-header-separator').forEach(header => {
                headerObserver.observe(header);
            });

            // Observer for loading more months
            const loadObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const now = Date.now();
                    // Skip loading during initial render, if already loading, or if debounce period hasn't passed
                    if (entry.isIntersecting && !isLoadingMonths && !isInitialMonthRender && (now - lastLoadTime > LOAD_DEBOUNCE_MS)) {
                        const block = entry.target;
                        const month = parseInt(block.dataset.month);
                        const year = parseInt(block.dataset.year);

                        if (month === loadedMonthStart.month && year === loadedMonthStart.year) {
                            // Near top - load previous month
                            lastLoadTime = now;
                            loadPreviousMonth();
                        } else if (month === loadedMonthEnd.month && year === loadedMonthEnd.year) {
                            // Near bottom - load next month
                            lastLoadTime = now;
                            loadNextMonth();
                        }
                    }
                });
            }, {
                root: null,
                threshold: 0.1,
                rootMargin: '100px 0px'  // Reduced from 200px to load closer to edge
            });

            // Observe first and last month blocks
            const blocks = monthList.querySelectorAll('.month-block');
            if (blocks.length > 0) {
                loadObserver.observe(blocks[0]);
                loadObserver.observe(blocks[blocks.length - 1]);
            }

            monthScrollObserver = { header: headerObserver, load: loadObserver };
        }

        // Create skeleton placeholder for month loading
        function createMonthSkeleton() {
            const skeleton = document.createElement('div');
            skeleton.className = 'month-skeleton-container';
            for (let i = 0; i < 5; i++) {
                const row = document.createElement('div');
                row.className = 'skeleton-row';
                skeleton.appendChild(row);
            }
            return skeleton;
        }

        // Load previous month at the top
        function loadPreviousMonth() {
            isLoadingMonths = true;

            let newMonth = loadedMonthStart.month - 1;
            let newYear = loadedMonthStart.year;
            if (newMonth < 0) {
                newMonth = 11;
                newYear--;
            }

            // Show skeleton placeholder
            const skeleton = createMonthSkeleton();
            monthList.insertBefore(skeleton, monthList.firstChild);

            // Brief delay for skeleton visibility
            setTimeout(() => {
                // Remove skeleton
                skeleton.remove();

                // Record scroll position before inserting content
                const scrollContainer = document.documentElement;
                const scrollTop = scrollContainer.scrollTop || document.body.scrollTop;
                const oldHeight = monthList.scrollHeight;

                // Create elements for the new month
            const fragment = document.createDocumentFragment();
            const today = new Date();
            const isCurrentMonth = today.getMonth() === newMonth && today.getFullYear() === newYear;

            // Month header
            const monthHeader = document.createElement('div');
            monthHeader.className = 'month-header-separator';
            monthHeader.dataset.month = newMonth;
            monthHeader.dataset.year = newYear;
            const headerTitle = document.createElement('div');
            headerTitle.className = 'month-header-title';
            headerTitle.textContent = `${monthNames[newMonth]} ${newYear}`;
            monthHeader.appendChild(headerTitle);
            fragment.appendChild(monthHeader);

            // Month block
            const monthBlock = document.createElement('div');
            monthBlock.className = 'month-block';
            monthBlock.dataset.month = newMonth;
            monthBlock.dataset.year = newYear;

            const lastDay = new Date(newYear, newMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            let lastWeekNum = -1;

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(newYear, newMonth, day);
                const isToday = isCurrentMonth && day === today.getDate();
                const dateStr = formatDateForInput(date);
                const weekdayIndex = getWeekdayFromDate(date);
                const tasksForDay = getTasksForDate(date);
                const hasNoTasks = tasksForDay.length === 0;

                const weekNum = Math.floor((day + getWeekdayFromDate(new Date(newYear, newMonth, 1)) - 1) / 7);
                if (lastWeekNum >= 0 && weekNum > lastWeekNum) {
                    const weekSep = document.createElement('div');
                    weekSep.className = 'week-separator';
                    monthBlock.appendChild(weekSep);
                }
                lastWeekNum = weekNum;

                const section = createDateSection(date, dateStr, day, weekdayIndex, tasksForDay, isToday, hasNoTasks);
                monthBlock.appendChild(section);
            }

            fragment.appendChild(monthBlock);

            // Insert at beginning
            monthList.insertBefore(fragment, monthList.firstChild);

            // Adjust scroll position to compensate for inserted content
            const newHeight = monthList.scrollHeight;
            const heightDiff = newHeight - oldHeight;
            if (heightDiff > 0) {
                window.scrollTo(0, scrollTop + heightDiff);
            }

            // Update loaded range
            loadedMonthStart = { month: newMonth, year: newYear };

            // Update observers after a brief delay to avoid triggering during scroll adjustment
            setTimeout(() => {
                setupMonthScrollObserver();
                isLoadingMonths = false;
            }, 50);
            }, 100); // End skeleton delay
        }

        // Load next month at the bottom
        function loadNextMonth() {
            isLoadingMonths = true;

            let newMonth = loadedMonthEnd.month + 1;
            let newYear = loadedMonthEnd.year;
            if (newMonth > 11) {
                newMonth = 0;
                newYear++;
            }

            // Show skeleton placeholder
            const skeleton = createMonthSkeleton();
            monthList.appendChild(skeleton);

            // Brief delay for skeleton visibility
            setTimeout(() => {
                // Remove skeleton
                skeleton.remove();

                const today = new Date();
                const isCurrentMonth = today.getMonth() === newMonth && today.getFullYear() === newYear;

                // Month header
                const monthHeader = document.createElement('div');
            monthHeader.className = 'month-header-separator';
            monthHeader.dataset.month = newMonth;
            monthHeader.dataset.year = newYear;
            const headerTitle = document.createElement('div');
            headerTitle.className = 'month-header-title';
            headerTitle.textContent = `${monthNames[newMonth]} ${newYear}`;
            monthHeader.appendChild(headerTitle);
            monthList.appendChild(monthHeader);

            // Month block
            const monthBlock = document.createElement('div');
            monthBlock.className = 'month-block';
            monthBlock.dataset.month = newMonth;
            monthBlock.dataset.year = newYear;

            const lastDay = new Date(newYear, newMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            let lastWeekNum = -1;

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(newYear, newMonth, day);
                const isToday = isCurrentMonth && day === today.getDate();
                const dateStr = formatDateForInput(date);
                const weekdayIndex = getWeekdayFromDate(date);
                const tasksForDay = getTasksForDate(date);
                const hasNoTasks = tasksForDay.length === 0;

                const weekNum = Math.floor((day + getWeekdayFromDate(new Date(newYear, newMonth, 1)) - 1) / 7);
                if (lastWeekNum >= 0 && weekNum > lastWeekNum) {
                    const weekSep = document.createElement('div');
                    weekSep.className = 'week-separator';
                    monthBlock.appendChild(weekSep);
                }
                lastWeekNum = weekNum;

                const section = createDateSection(date, dateStr, day, weekdayIndex, tasksForDay, isToday, hasNoTasks);
                monthBlock.appendChild(section);
            }

            monthList.appendChild(monthBlock);

            // Update loaded range
            loadedMonthEnd = { month: newMonth, year: newYear };

            // Update observers
            setupMonthScrollObserver();

            isLoadingMonths = false;
            }, 100); // End skeleton delay
        }

        // Desktop: 7-column grid with task previews
        function renderMonthGridView() {
            monthGrid.innerHTML = '';

            // Weekday headers
            const weekdayHeaders = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            weekdayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.className = 'month-weekday-header';
                header.textContent = day;
                monthGrid.appendChild(header);
            });

            // Get first day and days in month
            const firstDay = new Date(viewingYear, viewingMonth, 1);
            const lastDay = new Date(viewingYear, viewingMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const jsStartDay = firstDay.getDay();
            const startDayOfWeek = jsStartDay === 0 ? 6 : jsStartDay - 1;

            const today = new Date();
            const isCurrentMonth = today.getMonth() === viewingMonth && today.getFullYear() === viewingYear;

            // Empty cells before first day
            for (let i = 0; i < startDayOfWeek; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'month-day empty';
                monthGrid.appendChild(emptyCell);
            }

            // Day cells
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(viewingYear, viewingMonth, day);
                const isToday = isCurrentMonth && day === today.getDate();
                const dateStr = formatDateForInput(date);

                const dayCell = document.createElement('div');
                dayCell.className = 'month-day' + (isToday ? ' today' : '');
                dayCell.dataset.date = dateStr;

                const dayNumber = document.createElement('div');
                dayNumber.className = 'month-day-number';
                dayNumber.textContent = day;
                dayCell.appendChild(dayNumber);

                // Task previews (show up to 2, then "+X more")
                const tasksForDay = getTasksForDate(date);
                const maxVisible = 2;

                if (tasksForDay.length > 0) {
                    const tasksToShow = tasksForDay.slice(0, maxVisible);

                    tasksToShow.forEach(task => {
                        const preview = document.createElement('div');
                        preview.className = 'month-task-preview' + (task.completed ? ' completed' : '');
                        preview.dataset.taskId = task.id;
                        preview.dataset.dateStr = dateStr;
                        if (task.dailyId) preview.dataset.dailyId = task.dailyId;
                        if (task.pattern) preview.dataset.pattern = task.pattern;
                        if (task.type) preview.dataset.type = task.type;

                        // Checkbox
                        const checkbox = document.createElement('span');
                        checkbox.className = 'month-task-checkbox' + (task.completed ? ' checked' : '');

                        // Recurring indicator
                        const isRepeatingTask = task.type === 'daily' || task.type === 'custom' || task.type === 'every-n-days' || task.type === 'monthly';
                        let recurringEl = null;
                        if (isRepeatingTask) {
                            recurringEl = document.createElement('span');
                            recurringEl.className = 'recurring-indicator';
                            recurringEl.textContent = '↻';
                            recurringEl.dataset.tooltip = getRecurringTooltip(task);
                        }

                        // Category indicator
                        const indicator = document.createElement('span');
                        indicator.className = 'category-indicator';
                        indicator.style.background = getCategoryColor(task.category);

                        const text = document.createElement('span');
                        text.className = 'month-task-text';
                        text.textContent = task.name;

                        // Task text click handler - opens notes modal for all tasks
                        text.addEventListener('click', (e) => {
                            e.stopPropagation();
                            openNotesModal(task.id);
                        });

                        // Delete button
                        const deleteBtn = document.createElement('button');
                        deleteBtn.type = 'button';
                        deleteBtn.className = 'month-task-delete';
                        deleteBtn.innerHTML = '&times;';
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            handleGridTaskDelete(preview);
                        });

                        preview.appendChild(checkbox);
                        if (recurringEl) preview.appendChild(recurringEl);
                        preview.appendChild(indicator);
                        preview.appendChild(text);
                        preview.appendChild(deleteBtn);

                        // Only checkbox toggles completion
                        checkbox.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleGridTask(preview);
                        });

                        dayCell.appendChild(preview);
                    });

                    if (tasksForDay.length > maxVisible) {
                        const moreBtn = document.createElement('div');
                        moreBtn.className = 'month-more-tasks';
                        moreBtn.textContent = `+${tasksForDay.length - maxVisible} more`;
                        moreBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            openBottomSheet(dateStr);
                        });
                        dayCell.appendChild(moreBtn);
                    }
                }

                // Click on empty space to open bottom sheet
                dayCell.addEventListener('click', (e) => {
                    if (!e.target.closest('.month-task-preview')) {
                        openBottomSheet(dateStr);
                    }
                });

                monthGrid.appendChild(dayCell);
            }

            // Fill remaining cells
            const totalCells = startDayOfWeek + daysInMonth;
            const remainingCells = (7 - (totalCells % 7)) % 7;
            for (let i = 0; i < remainingCells; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'month-day empty';
                monthGrid.appendChild(emptyCell);
            }
        }

        // Plan View - Weekly Planning Interface
        let planViewingDate = new Date();

        function getPlanWeekDates(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            // Get Monday of the week (adjust for Sunday = 0)
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
            const monday = new Date(d.setDate(diff));

            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                weekDates.push(date);
            }
            return weekDates;
        }

        function formatPlanWeekTitle(weekDates) {
            const startDate = weekDates[0];
            const endDate = weekDates[6];
            const startMonth = monthNames[startDate.getMonth()].slice(0, 3);
            const endMonth = monthNames[endDate.getMonth()].slice(0, 3);

            if (startDate.getMonth() === endDate.getMonth()) {
                return `Week of ${startMonth} ${startDate.getDate()} - ${endDate.getDate()}`;
            } else {
                return `Week of ${startMonth} ${startDate.getDate()} - ${endMonth} ${endDate.getDate()}`;
            }
        }

        function renderPlanView() {
            const weekDates = getPlanWeekDates(planViewingDate);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Update header
            planWeekTitle.textContent = formatPlanWeekTitle(weekDates);

            // Calculate week stats
            let totalTasks = 0;
            let completedTasks = 0;

            weekDates.forEach(date => {
                const tasksForDay = getTasksForDate(date);
                totalTasks += tasksForDay.length;
                completedTasks += tasksForDay.filter(t => t.completed).length;
            });

            planWeekStats.innerHTML = `<span class="plan-stats-text">${completedTasks} of ${totalTasks} tasks completed this week</span>`;

            // Render day sections
            planDays.innerHTML = '';

            weekDates.forEach(date => {
                const dateStr = formatDateForInput(date);
                const isToday = date.getTime() === today.getTime();
                const tasksForDay = getTasksForDate(date);

                const section = document.createElement('div');
                section.className = 'plan-day-section' + (isToday ? ' is-today' : '');
                section.dataset.date = dateStr;

                // Day header
                const header = document.createElement('div');
                header.className = 'plan-day-header';

                const dayInfo = document.createElement('div');
                dayInfo.className = 'plan-day-info';

                const dayName = document.createElement('span');
                dayName.className = 'plan-day-name';
                dayName.textContent = days[getWeekdayFromDate(date)];

                const dayDate = document.createElement('span');
                dayDate.className = 'plan-day-date';
                dayDate.textContent = `${monthNames[date.getMonth()].slice(0, 3)} ${date.getDate()}`;

                dayInfo.appendChild(dayName);
                dayInfo.appendChild(dayDate);

                if (isToday) {
                    const todayBadge = document.createElement('span');
                    todayBadge.className = 'plan-today-badge';
                    todayBadge.textContent = 'Today';
                    dayInfo.appendChild(todayBadge);
                }

                header.appendChild(dayInfo);

                if (tasksForDay.length > 0) {
                    const dayCount = document.createElement('span');
                    dayCount.className = 'plan-day-count';
                    dayCount.textContent = `${tasksForDay.length} task${tasksForDay.length !== 1 ? 's' : ''}`;
                    header.appendChild(dayCount);
                }

                section.appendChild(header);

                // Inline input container with gear icon
                const inputContainer = document.createElement('div');
                inputContainer.className = 'plan-inline-input-container';

                const inputWrapper = document.createElement('div');
                inputWrapper.className = 'plan-input-wrapper';

                const inlineInput = document.createElement('input');
                inlineInput.type = 'text';
                inlineInput.className = 'plan-inline-input';
                inlineInput.placeholder = `+ Add task...`;
                inlineInput.dataset.date = dateStr;

                inlineInput.addEventListener('keydown', (e) => {
                    if ((e.key === 'Enter' || e.keyCode === 13) && inlineInput.value.trim()) {
                        e.preventDefault();
                        const taskName = inlineInput.value.trim();
                        // Save scroll position before any DOM changes
                        const scrollY = window.scrollY;

                        // Show loading state
                        inputWrapper.classList.add('loading');

                        // Brief delay for perceived responsiveness
                        setTimeout(() => {
                            addQuickPlanTask(taskName, dateStr);
                            inlineInput.value = '';
                            inputWrapper.classList.remove('loading');
                            inlineInput.focus();
                            // Restore scroll position after task creation
                            requestAnimationFrame(() => {
                                window.scrollTo(0, scrollY);
                            });
                        }, 150);
                    }
                });

                const gearBtn = document.createElement('button');
                gearBtn.type = 'button';
                gearBtn.className = 'plan-gear-btn';
                gearBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>';
                gearBtn.title = 'Add with options';
                gearBtn.addEventListener('click', () => {
                    // Capture inline input value and pass to modal
                    const taskName = inlineInput.value.trim();
                    openCreateTaskModal(dateStr, null, taskName);
                    // Clear the inline input after opening modal
                    inlineInput.value = '';
                });

                // Spinner element for loading state
                const spinner = document.createElement('div');
                spinner.className = 'plan-input-spinner';

                inputWrapper.appendChild(inlineInput);
                inputWrapper.appendChild(gearBtn);
                inputWrapper.appendChild(spinner);
                inputContainer.appendChild(inputWrapper);
                section.appendChild(inputContainer);

                // Tasks container
                const tasksContainer = document.createElement('div');
                tasksContainer.className = 'plan-day-tasks';

                if (tasksForDay.length > 0) {
                    // Separate timed and untimed tasks
                    const timedTasks = tasksForDay.filter(t => t.time);
                    const untimedTasks = tasksForDay.filter(t => !t.time);

                    // Render timed tasks first
                    timedTasks.forEach(task => {
                        const taskEl = createPlanTaskElement(task, dateStr);
                        tasksContainer.appendChild(taskEl);
                    });

                    // Add divider if both timed and untimed tasks exist
                    if (timedTasks.length > 0 && untimedTasks.length > 0) {
                        const divider = document.createElement('div');
                        divider.className = 'time-section-divider';
                        tasksContainer.appendChild(divider);
                    }

                    // Render untimed tasks
                    untimedTasks.forEach(task => {
                        const taskEl = createPlanTaskElement(task, dateStr);
                        tasksContainer.appendChild(taskEl);
                    });
                }

                section.appendChild(tasksContainer);
                planDays.appendChild(section);
            });
        }

        function createPlanTaskElement(task, dateStr) {
            const taskEl = document.createElement('div');
            taskEl.className = 'task-item' + (task.completed ? ' completed' : '');
            taskEl.dataset.taskId = task.id;
            taskEl.dataset.dateStr = dateStr;

            if (task.dailyId) {
                taskEl.dataset.dailyId = task.dailyId;
            }
            if (task.pattern) {
                taskEl.dataset.pattern = task.pattern;
            }
            if (task.type) {
                taskEl.dataset.type = task.type;
            }

            const checkedClass = task.completed ? ' checked' : '';
            const completedClass = task.completed ? ' completed' : '';
            const categoryColor = getCategoryColor(task.category);
            const timeDisplay = task.time ? `<span class="task-time">${formatTime24Hour(task.time)}</span>` : '';

            const isRepeatingTask = task.type === 'daily' || task.type === 'custom' || task.type === 'every-n-days' || task.type === 'monthly';
            let recurringIndicator = '';
            if (isRepeatingTask) {
                const tooltip = getRecurringTooltip(task);
                recurringIndicator = `<span class="recurring-indicator" data-tooltip="${tooltip}">↻</span>`;
            }

            taskEl.innerHTML = `
                <div class="task-checkbox${checkedClass}"></div>
                ${recurringIndicator}
                <div class="category-indicator" style="background: ${categoryColor};"></div>
                <div class="task-content">
                    ${timeDisplay}
                    <span class="task-name${completedClass}">${escapeHtml(task.name)}</span>
                </div>
                <button type="button" class="delete-button">&times;</button>
            `;

            // Checkbox click handler
            const checkbox = taskEl.querySelector('.task-checkbox');
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePlanTask(taskEl);
            });

            // Delete button click handler
            const deleteBtn = taskEl.querySelector('.delete-button');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                handleDeleteTask(taskEl);
            });

            // Task name interaction handlers
            // Quick tap/click → view details, Long press (500ms+) → edit
            const taskNameEl = taskEl.querySelector('.task-name');
            let longPressTimer = null;
            let isLongPress = false;
            let mouseDownTime = 0;

            // Mouse events for desktop
            taskNameEl.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only left click
                mouseDownTime = Date.now();
                isLongPress = false;
                taskNameEl.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskNameEl.classList.remove('pressing');
                    openEditTaskModal(task.id, dateStr);
                }, 500);
            });

            taskNameEl.addEventListener('mouseup', (e) => {
                taskNameEl.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskNameEl.addEventListener('mouseleave', (e) => {
                taskNameEl.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            taskNameEl.addEventListener('click', (e) => {
                e.stopPropagation();
                // Only open detail modal if it wasn't a long press
                if (!isLongPress) {
                    openTaskDetailModal(task.id, dateStr);
                }
                isLongPress = false;
            });

            // Touch events for mobile
            taskNameEl.addEventListener('touchstart', (e) => {
                isLongPress = false;
                taskNameEl.classList.add('pressing');
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    taskNameEl.classList.remove('pressing');
                    openEditTaskModal(task.id, dateStr);
                }, 500);
            }, { passive: true });

            taskNameEl.addEventListener('touchend', (e) => {
                taskNameEl.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                // If it wasn't a long press, open detail modal
                if (!isLongPress) {
                    e.preventDefault(); // Prevent click event
                    openTaskDetailModal(task.id, dateStr);
                }
            });

            taskNameEl.addEventListener('touchmove', (e) => {
                // Cancel long press if user moves finger (scrolling)
                taskNameEl.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            }, { passive: true });

            taskNameEl.addEventListener('touchcancel', (e) => {
                taskNameEl.classList.remove('pressing');
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            return taskEl;
        }

        function togglePlanTask(taskEl) {
            const taskId = taskEl.dataset.taskId;
            const dateStr = taskEl.dataset.dateStr;
            const dailyId = taskEl.dataset.dailyId;

            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            const completionKey = dailyId || taskId;
            const completionDate = task.type === 'onetime' ? task.date : dateStr;
            const wasCompleted = isTaskCompletedForDate(completionKey, completionDate);
            const isNowCompleted = !wasCompleted;

            setTaskCompletedForDate(completionKey, completionDate, isNowCompleted);

            // Update UI
            const checkbox = taskEl.querySelector('.task-checkbox');
            const taskName = taskEl.querySelector('.task-name');
            checkbox.classList.toggle('checked', isNowCompleted);
            taskName.classList.toggle('completed', isNowCompleted);
            taskEl.classList.toggle('completed', isNowCompleted);

            // Enhanced visual feedback on completion
            if (isNowCompleted) {
                // Add completing animations
                checkbox.classList.add('completing');
                taskEl.classList.add('completing');

                // Remove animation classes after animation completes
                setTimeout(() => {
                    checkbox.classList.remove('completing');
                    taskEl.classList.remove('completing');
                }, 500);
            }

            // XP popup (positioned near checkbox)
            const popup = document.createElement('span');
            popup.className = 'xp-popup ' + (isNowCompleted ? 'gain' : 'lose');
            popup.textContent = (isNowCompleted ? '+' : '-') + '10 XP';
            checkbox.appendChild(popup);
            setTimeout(() => popup.remove(), 600);

            // Update week stats
            updatePlanWeekStats();

            // Update XP
            totalXp += isNowCompleted ? 10 : -10;
            if (totalXp < 0) totalXp = 0;
            updateLevelDisplay();

            saveData();

            // Update week stats
            renderPlanView();

            // Check achievements
            if (isNowCompleted) {
                checkAchievements();
            }
        }

        function navigatePlanWeek(delta) {
            planViewingDate.setDate(planViewingDate.getDate() + (delta * 7));
            renderPlanView();
        }

        function goToPlanCurrentWeek() {
            planViewingDate = new Date();
            renderPlanView();
        }

        function addQuickPlanTask(taskName, dateStr) {
            const taskId = 'task-' + (++taskIdCounter);

            const newTask = {
                id: taskId,
                name: taskName,
                type: 'onetime',
                category: 'general',
                date: dateStr
            };

            tasks.push(newTask);
            saveData();

            // Find the day section and add task with animation
            const daySection = planDays.querySelector(`.plan-day-section[data-date="${dateStr}"]`);
            if (daySection) {
                const tasksContainer = daySection.querySelector('.plan-day-tasks');

                // Create task element with completed status
                const taskWithStatus = {
                    ...newTask,
                    completed: false
                };
                const taskEl = createPlanTaskElement(taskWithStatus, dateStr);
                taskEl.classList.add('new-task');

                // Append to tasks container
                tasksContainer.appendChild(taskEl);

                // Update day count in header
                const dayHeader = daySection.querySelector('.plan-day-header');
                let dayCount = dayHeader.querySelector('.plan-day-count');
                const currentTasks = tasksContainer.querySelectorAll('.task-item').length;

                if (dayCount) {
                    dayCount.textContent = `${currentTasks} task${currentTasks !== 1 ? 's' : ''}`;
                } else {
                    dayCount = document.createElement('span');
                    dayCount.className = 'plan-day-count';
                    dayCount.textContent = `${currentTasks} task${currentTasks !== 1 ? 's' : ''}`;
                    dayHeader.appendChild(dayCount);
                }

                // Update week stats
                updatePlanWeekStats();

                // Remove animation class after animation completes
                setTimeout(() => {
                    taskEl.classList.remove('new-task');
                }, 300);
            }

            // Keep focus on the input for continuous adding (without scrolling)
            const input = planDays.querySelector(`.plan-inline-input[data-date="${dateStr}"]`);
            if (input) {
                // Save scroll position
                const scrollY = window.scrollY;
                // Focus with preventScroll option (for modern browsers)
                input.focus({ preventScroll: true });
                // Restore scroll position (fallback for browsers that don't support preventScroll)
                requestAnimationFrame(() => {
                    if (window.scrollY !== scrollY) {
                        window.scrollTo(0, scrollY);
                    }
                });
            }
        }

        function updatePlanWeekStats() {
            const weekDates = getPlanWeekDates(planViewingDate);
            let totalTasks = 0;
            let completedTasks = 0;

            weekDates.forEach(date => {
                const tasksForDay = getTasksForDate(date);
                totalTasks += tasksForDay.length;
                completedTasks += tasksForDay.filter(t => t.completed).length;
            });

            planWeekStats.innerHTML = `<span class="plan-stats-text">${completedTasks} of ${totalTasks} tasks completed this week</span>`;
        }

        // Stats View
        function renderStatsView() {
            const stats = calculateStats();

            // Quick stats
            statTotalCompleted.textContent = stats.totalCompleted;
            statStreak.textContent = stats.streak;
            statCompletionRate.textContent = stats.completionRate + '%';
            statLevel.textContent = getLevel(totalXp);

            // Weekly summary
            weekDateRange.textContent = stats.weekRange;
            weekProgressText.textContent = `${stats.weekCompleted} of ${stats.weekTotal} tasks completed`;
            const weekPercent = stats.weekTotal > 0 ? Math.round((stats.weekCompleted / stats.weekTotal) * 100) : 0;
            weekProgressPercent.textContent = weekPercent + '%';
            weekProgressFill.style.width = weekPercent + '%';

            // Category breakdown
            renderCategoryBreakdown(stats.categoryStats);

            // Time allocation
            renderTimeAllocation();

            // Achievements
            renderAchievements();
        }

        function calculateStats() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Get current week dates (Monday to Sunday)
            const weekDates = getWeekDates(today);
            const weekStart = weekDates[0];
            const weekEnd = weekDates[6];

            // Calculate total completed (all time)
            let totalCompleted = 0;
            for (const taskId in taskCompletions) {
                totalCompleted += Object.keys(taskCompletions[taskId]).length;
            }

            // Calculate streak (consecutive days with at least 1 completion)
            const streak = calculateStreak();

            // Calculate completion rate
            const completionRate = calculateCompletionRate();

            // Calculate week stats
            const weekStats = calculateWeekStats(weekDates);

            // Format week range
            const startMonth = monthNames[weekStart.getMonth()].slice(0, 3);
            const endMonth = monthNames[weekEnd.getMonth()].slice(0, 3);
            let weekRange;
            if (weekStart.getMonth() === weekEnd.getMonth()) {
                weekRange = `${startMonth} ${weekStart.getDate()} - ${weekEnd.getDate()}`;
            } else {
                weekRange = `${startMonth} ${weekStart.getDate()} - ${endMonth} ${weekEnd.getDate()}`;
            }

            return {
                totalCompleted,
                streak,
                completionRate,
                weekRange,
                weekCompleted: weekStats.completed,
                weekTotal: weekStats.total,
                categoryStats: weekStats.byCategory
            };
        }

        function calculateStreak() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let streak = 0;
            let checkDate = new Date(today);

            // Check if today has any completions
            const todayStr = formatDateForInput(checkDate);
            const todayHasCompletion = hasCompletionOnDate(todayStr);

            // If today has no completion, start checking from yesterday
            if (!todayHasCompletion) {
                checkDate.setDate(checkDate.getDate() - 1);
            }

            // Count consecutive days with completions going backwards
            while (true) {
                const dateStr = formatDateForInput(checkDate);
                if (hasCompletionOnDate(dateStr)) {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else {
                    break;
                }

                // Safety limit (don't check more than a year back)
                if (streak > 365) break;
            }

            return streak;
        }

        function hasCompletionOnDate(dateStr) {
            for (const taskId in taskCompletions) {
                if (taskCompletions[taskId][dateStr]) {
                    return true;
                }
            }
            return false;
        }

        function calculateCompletionRate() {
            // Get all unique task-date combinations that could have been completed
            let totalPossible = 0;
            let totalCompleted = 0;

            // For each task, count how many times it could have been completed
            // and how many times it was actually completed
            for (const taskId in taskCompletions) {
                const completions = taskCompletions[taskId];
                totalCompleted += Object.keys(completions).length;
            }

            // Count total possible completions based on tasks
            const today = new Date();
            tasks.forEach(task => {
                if (task.type === 'onetime') {
                    totalPossible++;
                } else if (task.type === 'daily') {
                    // Count days from task creation to today (simplified: assume 30 days max)
                    totalPossible += 30;
                } else if (task.type === 'custom') {
                    // Custom tasks: count based on pattern (simplified: 30 days / 7 * days in pattern)
                    const daysCount = task.pattern.split(',').length;
                    totalPossible += Math.round((30 / 7) * daysCount);
                }
            });

            // Simple approach: just use actual completed / total created tasks * 100
            // This gives a more meaningful rate
            if (tasks.length === 0) return 0;

            // Calculate based on completion count vs task count
            const rate = totalCompleted > 0 ? Math.min(Math.round((totalCompleted / Math.max(totalPossible, 1)) * 100), 100) : 0;
            return rate;
        }

        function calculateWeekStats(weekDates) {
            let completed = 0;
            let total = 0;
            const byCategory = {};

            // Category names for display
            const categoryNames = {
                general: 'General',
                health: 'Health & Fitness',
                learning: 'Learning',
                creative: 'Creative',
                wellness: 'Wellness',
                productivity: 'Productivity',
                social: 'Social'
            };

            weekDates.forEach(date => {
                const dateStr = formatDateForInput(date);
                const tasksForDay = getTasksForDate(date);

                tasksForDay.forEach(task => {
                    const category = task.category || 'general';

                    // Initialize category if not exists
                    if (!byCategory[category]) {
                        byCategory[category] = {
                            name: categoryNames[category] || category,
                            color: getCategoryColor(category),
                            total: 0,
                            completed: 0
                        };
                    }

                    total++;
                    byCategory[category].total++;

                    if (task.completed) {
                        completed++;
                        byCategory[category].completed++;
                    }
                });
            });

            return { completed, total, byCategory };
        }

        function renderCategoryBreakdown(categoryStats) {
            categoryBreakdown.innerHTML = '';

            // Convert to array and sort by total tasks (descending)
            const categories = Object.entries(categoryStats)
                .filter(([key, data]) => data.total > 0)
                .sort((a, b) => b[1].total - a[1].total);

            if (categories.length === 0) {
                categoryBreakdown.innerHTML = '<div class="stats-empty">No tasks this week</div>';
                return;
            }

            // Find max task count for proportional bar widths
            const maxTasks = Math.max(...categories.map(([key, data]) => data.total));

            categories.forEach(([key, data]) => {
                // Completion percentage (fill inside the bar)
                const completionPercent = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;

                // Proportional bar width based on task count (minimum 40%)
                // This scales dynamically: category with most tasks = 100%, others proportionally smaller
                const barWidthPercent = Math.max(40, Math.round((data.total / maxTasks) * 100));

                const categoryEl = document.createElement('div');
                categoryEl.className = 'category-stat';
                categoryEl.innerHTML = `
                    <div class="category-stat-left">
                        <div class="category-stat-dot" style="background: ${data.color};"></div>
                        <span class="category-stat-name">${data.name}</span>
                    </div>
                    <div class="category-progress-wrapper">
                        <div class="category-progress-container" style="width: ${barWidthPercent}%;">
                            <div class="category-progress-fill" style="width: ${completionPercent}%; background: ${data.color};"></div>
                        </div>
                    </div>
                    <span class="category-stat-count">${data.completed}/${data.total}</span>
                `;

                categoryBreakdown.appendChild(categoryEl);
            });
        }

        // Time Allocation Functions
        function calculateTimeAllocation(weekDates) {
            const categoryMinutes = {};

            // Category names for display
            const categoryNames = {
                general: 'General',
                health: 'Health & Fitness',
                learning: 'Learning',
                creative: 'Creative',
                wellness: 'Wellness',
                productivity: 'Productivity',
                social: 'Social'
            };

            weekDates.forEach(date => {
                const tasksForDay = getTasksForDate(date);

                tasksForDay.forEach(task => {
                    // Only include tasks with both time and duration
                    if (task.time && task.duration) {
                        const category = task.category || 'general';

                        if (!categoryMinutes[category]) {
                            categoryMinutes[category] = {
                                name: categoryNames[category] || category,
                                color: getCategoryColor(category),
                                totalMinutes: 0,
                                completedMinutes: 0
                            };
                        }

                        categoryMinutes[category].totalMinutes += task.duration;
                        if (task.completed) {
                            categoryMinutes[category].completedMinutes += task.duration;
                        }
                    }
                });
            });

            return categoryMinutes;
        }

        function hexToRgba(hex, alpha) {
            // Remove # if present
            hex = hex.replace('#', '');

            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function formatTimeAllocation(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;

            if (hours > 0 && minutes > 0) {
                return `${hours}h ${minutes}m`;
            }
            if (hours > 0) {
                return `${hours}h`;
            }
            return `${minutes}m`;
        }

        function renderTimeAllocation() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const weekDates = getWeekDates(today);

            const categoryMinutes = calculateTimeAllocation(weekDates);

            // Convert to array and sort by total minutes (descending)
            const categories = Object.entries(categoryMinutes)
                .filter(([key, data]) => data.totalMinutes > 0)
                .sort((a, b) => b[1].totalMinutes - a[1].totalMinutes);

            // Handle empty state
            if (categories.length === 0) {
                timeAllocationSummary.textContent = '';
                timeAllocationBars.innerHTML = '<div class="time-allocation-empty">No time-scheduled tasks this week</div>';
                return;
            }

            // Calculate totals
            const grandTotalMinutes = categories.reduce((sum, [key, data]) => sum + data.totalMinutes, 0);
            const grandCompletedMinutes = categories.reduce((sum, [key, data]) => sum + data.completedMinutes, 0);
            const totalTimeStr = formatTimeAllocation(grandTotalMinutes);
            const completedTimeStr = formatTimeAllocation(grandCompletedMinutes);
            const categoryCount = categories.length;

            // Render summary
            timeAllocationSummary.textContent = `${completedTimeStr} of ${totalTimeStr} completed across ${categoryCount} ${categoryCount === 1 ? 'category' : 'categories'}`;

            // Find max for proportional widths (flex-grow)
            const maxMinutes = Math.max(...categories.map(([key, data]) => data.totalMinutes));

            // Render bars
            timeAllocationBars.innerHTML = '';

            categories.forEach(([key, data]) => {
                const timeStr = formatTimeAllocation(data.totalMinutes);
                // Completion percentage for bar fill (opaque vs transparent)
                const completionPercent = data.totalMinutes > 0
                    ? Math.round((data.completedMinutes / data.totalMinutes) * 100)
                    : 0;
                // Allocation percentage for label (category / total week time)
                const allocationPercent = grandTotalMinutes > 0
                    ? Math.round((data.totalMinutes / grandTotalMinutes) * 100)
                    : 0;
                const proportionalValue = data.totalMinutes / maxMinutes;

                const row = document.createElement('div');
                row.className = 'time-allocation-row';
                row.innerHTML = `
                    <div class="time-category-name">${data.name}</div>
                    <div class="time-bar-wrapper" style="flex-grow: ${proportionalValue.toFixed(3)};">
                        <div class="time-bar-container" style="background: ${hexToRgba(data.color, 0.3)};">
                            <div class="time-bar-fill" style="width: ${completionPercent}%; background: ${data.color};"></div>
                        </div>
                        <div class="time-label">${timeStr} (${allocationPercent}%)</div>
                    </div>
                `;

                timeAllocationBars.appendChild(row);
            });
        }

        // Achievement Functions
        function renderAchievements() {
            const stats = calculateStats();
            const currentStreak = stats.streak;
            const totalCompleted = stats.totalCompleted;

            // Render streak achievements
            renderAchievementGrid(streakAchievementsEl, ACHIEVEMENTS.streak, currentStreak);
            renderAchievementProgress(streakProgressEl, ACHIEVEMENTS.streak, currentStreak, 'days');

            // Render completion achievements
            renderAchievementGrid(completionAchievementsEl, ACHIEVEMENTS.completion, totalCompleted);
            renderAchievementProgress(completionProgressEl, ACHIEVEMENTS.completion, totalCompleted, 'tasks');
        }

        function renderAchievementGrid(container, achievements, currentValue) {
            container.innerHTML = '';

            achievements.forEach(achievement => {
                const isUnlocked = unlockedAchievements[achievement.id];
                const card = document.createElement('div');
                card.className = 'achievement-card' + (isUnlocked ? ' unlocked' : ' locked');

                let extraHtml = '';
                if (isUnlocked) {
                    const date = new Date(isUnlocked.date);
                    extraHtml = `<div class="achievement-date">${formatAchievementDate(date)}</div>`;
                } else {
                    // Show progress for locked achievements
                    const progress = Math.min(currentValue, achievement.threshold);
                    const percentage = Math.min((progress / achievement.threshold) * 100, 100);
                    extraHtml = `
                        <div class="card-progress">
                            <div class="card-progress-text">${progress}/${achievement.threshold}</div>
                            <div class="card-progress-bar">
                                <div class="card-progress-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }

                const checkmark = isUnlocked ? '<span class="achievement-check">✓</span>' : '';
                card.innerHTML = `
                    <div class="achievement-header">
                        ${checkmark}
                        <div class="achievement-name">${achievement.name}</div>
                    </div>
                    <div class="achievement-req">${achievement.requirement}</div>
                    <div class="achievement-xp">+${achievement.xp} XP</div>
                    ${extraHtml}
                `;

                container.appendChild(card);
            });
        }

        function renderAchievementProgress(container, achievements, currentValue, unit) {
            // Find next locked achievement
            let nextAchievement = null;
            for (const achievement of achievements) {
                if (!unlockedAchievements[achievement.id]) {
                    nextAchievement = achievement;
                    break;
                }
            }

            if (!nextAchievement) {
                container.innerHTML = '<span style="color: #737373;">All achievements unlocked!</span>';
                return;
            }

            const progress = Math.min(currentValue, nextAchievement.threshold);
            const percent = Math.round((progress / nextAchievement.threshold) * 100);

            container.innerHTML = `
                <span>Next: ${progress}/${nextAchievement.threshold} ${unit} to ${nextAchievement.name}</span>
                <div class="achievement-progress-bar">
                    <div class="achievement-progress-fill" style="width: ${percent}%;"></div>
                </div>
            `;
        }

        function formatAchievementDate(date) {
            const month = monthNames[date.getMonth()].slice(0, 3);
            return `${month} ${date.getDate()}, ${date.getFullYear()}`;
        }

        function checkAchievements() {
            const stats = calculateStats();
            const currentStreak = stats.streak;
            const totalCompleted = stats.totalCompleted;

            // Check streak achievements
            ACHIEVEMENTS.streak.forEach(achievement => {
                if (!unlockedAchievements[achievement.id] && currentStreak >= achievement.threshold) {
                    unlockAchievement(achievement);
                }
            });

            // Check completion achievements
            ACHIEVEMENTS.completion.forEach(achievement => {
                if (!unlockedAchievements[achievement.id] && totalCompleted >= achievement.threshold) {
                    unlockAchievement(achievement);
                }
            });
        }

        function unlockAchievement(achievement) {
            // Mark as unlocked
            unlockedAchievements[achievement.id] = {
                date: new Date().toISOString()
            };

            // Award XP
            totalXp += achievement.xp;
            updateLevelDisplay();

            // Save data
            saveData();

            // Show celebration
            showCelebration(achievement);

            // Update stats view if visible
            if (currentView === 'stats') {
                renderAchievements();
            }
        }

        function showCelebration(achievement) {
            celebrationName.textContent = achievement.name;
            celebrationReq.textContent = achievement.requirement;
            celebrationXp.textContent = '+' + achievement.xp + ' XP';

            celebrationOverlay.classList.add('active');

            // Auto dismiss after 3 seconds
            const autoDismiss = setTimeout(() => {
                closeCelebration();
            }, 3000);

            // Click to dismiss
            const clickHandler = () => {
                clearTimeout(autoDismiss);
                closeCelebration();
                celebrationOverlay.removeEventListener('click', clickHandler);
            };

            celebrationOverlay.addEventListener('click', clickHandler);
        }

        function closeCelebration() {
            celebrationOverlay.classList.remove('active');
        }

        function showResetConfirmation() {
            confirmOverlay.classList.add('active');
        }
        // Make available for inline onclick
        window.showResetConfirmation = showResetConfirmation;

        function hideResetConfirmation() {
            confirmOverlay.classList.remove('active');
        }
        // Make available for inline onclick
        window.hideResetConfirmation = hideResetConfirmation;

        function resetAchievements() {
            // Calculate XP to remove (sum of all unlocked achievement bonuses)
            let xpToRemove = 0;
            for (const achievementId in unlockedAchievements) {
                // Find the achievement definition
                const allAchievements = [...ACHIEVEMENTS.streak, ...ACHIEVEMENTS.completion];
                const achievement = allAchievements.find(a => a.id === achievementId);
                if (achievement) {
                    xpToRemove += achievement.xp;
                }
            }

            // Clear unlocked achievements (delete all keys to maintain reference)
            for (const key in unlockedAchievements) {
                delete unlockedAchievements[key];
            }

            // Subtract achievement XP from total
            totalXp = Math.max(0, totalXp - xpToRemove);

            // Save to localStorage
            saveData();

            // Update UI
            updateLevelDisplay();

            // Force clear and re-render achievement containers
            streakAchievementsEl.innerHTML = '';
            completionAchievementsEl.innerHTML = '';
            streakProgressEl.innerHTML = '';
            completionProgressEl.innerHTML = '';

            // Re-render achievements with fresh data
            renderAchievements();

            // Close confirmation modal
            hideResetConfirmation();
        }
        // Make available for inline onclick
        window.resetAchievements = resetAchievements;

        // Bottom Sheet
        function openBottomSheet(dateStr) {
            selectedSheetDate = dateStr;
            const date = new Date(dateStr + 'T00:00:00');
            sheetDate.textContent = formatDateForDisplay(date);

            renderBottomSheetTasks();

            bottomSheetOverlay.classList.add('active');
            bottomSheet.classList.add('open');
        }

        function renderBottomSheetTasks() {
            if (!selectedSheetDate) return;

            const date = new Date(selectedSheetDate + 'T00:00:00');
            const tasksForDay = getTasksForDate(date);

            sheetTasks.innerHTML = '';

            if (tasksForDay.length === 0) {
                sheetTasks.innerHTML = '<div class="empty-day">No tasks for this day</div>';
            } else {
                const tasksList = document.createElement('div');
                tasksList.className = 'day-tasks';

                tasksForDay.forEach(task => {
                    const taskEl = createTaskElement(task, selectedSheetDate);
                    tasksList.appendChild(taskEl);
                });

                sheetTasks.appendChild(tasksList);
            }

            // Add button to create task for this date
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'sheet-add-btn';
            addBtn.innerHTML = '+ Add task for this day';
            addBtn.addEventListener('click', () => {
                const dateToUse = selectedSheetDate;
                closeBottomSheet();
                openCreateTaskModal(dateToUse);
            });
            sheetTasks.appendChild(addBtn);
        }

        function closeBottomSheet() {
            bottomSheetOverlay.classList.remove('active');
            bottomSheet.classList.remove('open');
            selectedSheetDate = null;
        }

        // Task Creation Modal
        function openCreateTaskModal(presetDate = null, presetTime = null, presetTaskName = null) {
            // Reset edit mode
            isEditMode = false;
            editingTaskId = null;
            editingTaskDateStr = null;

            createTaskModal.classList.add('active');
            fabButton.classList.add('open');
            document.body.classList.add('modal-open');

            // Set modal title and button for create mode
            modalTitleText.textContent = 'New Task';
            modalSubmitBtn.textContent = 'Add Task';

            // Reset form
            modalTaskInput.value = '';
            modalNotesInput.value = '';
            updateNotesCharCount();

            // Pre-fill task name if provided (from Plan view gear icon)
            if (presetTaskName) {
                modalTaskInput.value = presetTaskName;
            }
            modalCategorySelect.value = 'general';
            categoryIndicator.style.background = getCategoryColor('general');
            modalTypeSelect.value = 'onetime';
            modalDateInput.value = presetDate || formatDateForInput(viewingDate);
            modalDateLabel.textContent = 'Date';
            modalDateField.style.display = 'block';
            modalEveryNDaysField.style.display = 'none';
            modalEveryNDaysInput.value = '2';
            modalMonthlyField.style.display = 'none';
            modalMonthlyDaySelect.value = new Date().getDate().toString();
            modalDayPickerField.style.display = 'none';
            clearModalDayPicker();

            // Set time field based on presetTime
            if (presetTime) {
                modalTimeToggle.checked = true;
                modalTimeInput.value = presetTime;
                modalDurationSelect.value = '60'; // Default 1 hour for timeline clicks
                timeInputWrapper.style.display = 'block';
            } else {
                modalTimeToggle.checked = false;
                modalTimeInput.value = '09:00';
                modalDurationSelect.value = '30';
                timeInputWrapper.style.display = 'none';
            }

            setTimeout(() => modalTaskInput.focus(), 100);
        }

        function openEditTaskModal(taskId, dateStr) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            // Set edit mode
            isEditMode = true;
            editingTaskId = taskId;
            editingTaskDateStr = dateStr;

            createTaskModal.classList.add('active');
            fabButton.classList.add('open');
            document.body.classList.add('modal-open');

            // Set modal title and button for edit mode
            modalTitleText.textContent = 'Edit Task';
            modalSubmitBtn.textContent = 'Save Changes';

            // Pre-fill form with task data
            modalTaskInput.value = task.name;
            modalNotesInput.value = task.notes || '';
            updateNotesCharCount();
            modalCategorySelect.value = task.category || 'general';
            categoryIndicator.style.background = getCategoryColor(task.category || 'general');
            modalTypeSelect.value = task.type || 'onetime';

            // Handle type-specific fields - hide all first
            modalDateField.style.display = 'none';
            modalEveryNDaysField.style.display = 'none';
            modalMonthlyField.style.display = 'none';
            modalDayPickerField.style.display = 'none';
            clearModalDayPicker();

            if (task.type === 'onetime' || !task.type) {
                modalDateLabel.textContent = 'Date';
                modalDateInput.value = task.date || formatDateForInput(viewingDate);
                modalDateField.style.display = 'block';
            } else if (task.type === 'daily') {
                // No extra fields for daily
            } else if (task.type === 'every-n-days') {
                modalEveryNDaysInput.value = task.repeatInterval || 2;
                modalEveryNDaysField.style.display = 'block';
                // Show date field for start date reference
                modalDateLabel.textContent = 'Starting from';
                modalDateInput.value = task.startDate || formatDateForInput(viewingDate);
                modalDateField.style.display = 'block';
            } else if (task.type === 'monthly') {
                modalMonthlyDaySelect.value = (task.monthlyDate || 1).toString();
                modalMonthlyField.style.display = 'block';
            } else if (task.type === 'custom') {
                modalDayPickerField.style.display = 'block';
                // Select the days from the pattern
                if (task.pattern) {
                    const days = task.pattern.split(',').map(Number);
                    days.forEach(day => {
                        const btn = modalDayPicker.querySelector(`[data-day="${day}"]`);
                        if (btn) btn.classList.add('selected');
                    });
                }
            }

            // Handle time field
            if (task.time) {
                modalTimeToggle.checked = true;
                modalTimeInput.value = task.time;
                modalDurationSelect.value = (task.duration || 30).toString();
                timeInputWrapper.style.display = 'block';
            } else {
                modalTimeToggle.checked = false;
                modalTimeInput.value = '09:00';
                modalDurationSelect.value = '30';
                timeInputWrapper.style.display = 'none';
            }

            setTimeout(() => modalTaskInput.focus(), 100);
        }

        function closeCreateTaskModal() {
            createTaskModal.classList.remove('active');
            fabButton.classList.remove('open');
            document.body.classList.remove('modal-open');
            // Clear notes input and reset character count
            modalNotesInput.value = '';
            updateNotesCharCount();
            // Reset edit mode
            isEditMode = false;
            editingTaskId = null;
            editingTaskDateStr = null;
        }

        // Task Detail Modal Functions (Read-only view)
        function openTaskDetailModal(taskId, dateStr) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            currentDetailTaskId = taskId;
            currentDetailDateStr = dateStr;

            // Category names for display
            const categoryNames = {
                general: 'General',
                health: 'Health & Fitness',
                learning: 'Learning',
                creative: 'Creative',
                wellness: 'Wellness',
                productivity: 'Productivity',
                social: 'Social'
            };

            // Set task name
            taskDetailName.textContent = task.name;

            // Set category
            const category = task.category || 'general';
            const categoryDot = taskDetailCategory.querySelector('.task-detail-category-dot');
            const categoryName = taskDetailCategory.querySelector('.task-detail-category-name');
            categoryDot.style.background = getCategoryColor(category);
            categoryName.textContent = categoryNames[category] || category;

            // Set task type
            let typeLabel = 'One-time';
            if (task.type === 'daily') {
                typeLabel = 'Daily';
            } else if (task.type === 'every-n-days' && task.repeatInterval) {
                typeLabel = `Every ${task.repeatInterval} days`;
            } else if (task.type === 'monthly' && task.monthlyDate) {
                const daySuffix = (day) => {
                    if (day >= 11 && day <= 13) return 'th';
                    switch (day % 10) {
                        case 1: return 'st';
                        case 2: return 'nd';
                        case 3: return 'rd';
                        default: return 'th';
                    }
                };
                typeLabel = `Monthly (${task.monthlyDate}${daySuffix(task.monthlyDate)})`;
            } else if (task.type === 'custom' && task.pattern) {
                const patternDays = task.pattern.split(',').map(Number);
                if (patternDays.length === 7) {
                    typeLabel = 'Daily';
                } else if (patternDays.length === 5 && patternDays.join(',') === '0,1,2,3,4') {
                    typeLabel = 'Weekdays';
                } else if (patternDays.length === 2 && patternDays.join(',') === '5,6') {
                    typeLabel = 'Weekends';
                } else {
                    const dayAbbrevs = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                    typeLabel = patternDays.map(d => dayAbbrevs[d]).join(', ');
                }
            }
            // Add time to type label if set
            if (task.time) {
                typeLabel += ` at ${formatTime24Hour(task.time)}`;
            }
            taskDetailType.textContent = typeLabel;

            // Set notes
            if (task.notes && task.notes.trim()) {
                taskDetailNotes.textContent = task.notes;
                taskDetailNotes.classList.remove('empty');
            } else {
                taskDetailNotes.textContent = 'No notes added yet';
                taskDetailNotes.classList.add('empty');
            }

            taskDetailModal.classList.add('active');
        }

        function closeTaskDetailModal() {
            taskDetailModal.classList.remove('active');
            currentDetailTaskId = null;
            currentDetailDateStr = null;
        }

        // Notes Modal Functions
        let currentNotesTaskId = null;

        function openNotesModal(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            currentNotesTaskId = taskId;
            notesModalTitle.textContent = task.name;
            notesModalTextarea.value = task.notes || '';
            notesModal.classList.add('active');

            // Focus textarea after animation
            setTimeout(() => notesModalTextarea.focus(), 100);
        }

        function closeNotesModal() {
            notesModal.classList.remove('active');
            currentNotesTaskId = null;
        }

        function saveNotes() {
            if (!currentNotesTaskId) return;

            const task = tasks.find(t => t.id === currentNotesTaskId);
            if (!task) return;

            const newNotes = notesModalTextarea.value.trim();

            if (newNotes) {
                task.notes = newNotes;
            } else {
                delete task.notes;
            }

            saveData();
            closeNotesModal();
        }

        function updateNotesCharCount() {
            const length = modalNotesInput.value.length;
            const maxLength = 500;
            notesCharCount.textContent = `${length}/${maxLength}`;
        }

        function clearModalDayPicker() {
            modalDayPicker.querySelectorAll('.modal-day-toggle').forEach(btn => {
                btn.classList.remove('selected');
            });
        }

        function getSelectedModalDays() {
            const selected = [];
            modalDayPicker.querySelectorAll('.modal-day-toggle.selected').forEach(btn => {
                selected.push(parseInt(btn.dataset.day));
            });
            return selected.sort((a, b) => a - b);
        }

        function addTask() {
            const taskName = modalTaskInput.value.trim();
            if (!taskName) return;

            const type = modalTypeSelect.value;
            const category = modalCategorySelect.value;
            const notes = modalNotesInput.value.trim();

            if (isEditMode && editingTaskId) {
                // Edit existing task
                const taskIndex = tasks.findIndex(t => t.id === editingTaskId);
                if (taskIndex === -1) return;

                const task = tasks[taskIndex];

                // Update task properties
                task.name = taskName;
                task.category = category;
                task.notes = notes || undefined;
                if (!notes) delete task.notes;

                // Handle time field
                if (modalTimeToggle.checked && modalTimeInput.value) {
                    task.time = modalTimeInput.value;
                    task.duration = parseInt(modalDurationSelect.value) || 30;
                } else {
                    delete task.time;
                    delete task.duration;
                }

                // Handle type changes
                const oldType = task.type;
                task.type = type;

                // Clean up old fields based on new type
                const isRepeating = type !== 'onetime';
                if (isRepeating && !task.dailyId) {
                    task.dailyId = 'daily-' + (++dailyTaskCounter);
                } else if (!isRepeating) {
                    delete task.dailyId;
                }

                // Save old values before cleanup
                const oldStartDate = task.startDate;

                // Remove fields not needed for this type
                delete task.pattern;
                delete task.date;
                delete task.repeatInterval;
                delete task.startDate;
                delete task.monthlyDate;

                if (type === 'daily') {
                    task.pattern = 'daily';
                } else if (type === 'custom') {
                    const selectedDays = getSelectedModalDays();
                    if (selectedDays.length === 0) {
                        alert('Please select at least one day');
                        return;
                    }
                    task.pattern = selectedDays.join(',');
                } else if (type === 'every-n-days') {
                    const interval = parseInt(modalEveryNDaysInput.value) || 2;
                    if (interval < 2 || interval > 30) {
                        alert('Please enter a number between 2 and 30');
                        return;
                    }
                    task.repeatInterval = interval;
                    task.startDate = modalDateInput.value || oldStartDate || formatDateForInput(viewingDate);
                } else if (type === 'monthly') {
                    const monthlyDay = parseInt(modalMonthlyDaySelect.value) || 1;
                    task.monthlyDate = monthlyDay;
                } else {
                    // One-time
                    const date = modalDateInput.value;
                    if (!date) {
                        alert('Please select a date');
                        return;
                    }
                    task.date = date;
                }

                saveData();
            } else {
                // Create new task
                const taskId = 'task-' + (++taskIdCounter);

                const newTask = {
                    id: taskId,
                    name: taskName,
                    type: type,
                    category: category
                };

                // Add notes only if not empty (keeps data clean)
                if (notes) {
                    newTask.notes = notes;
                }

                // Add time and duration if toggle is on
                if (modalTimeToggle.checked && modalTimeInput.value) {
                    newTask.time = modalTimeInput.value;
                    newTask.duration = parseInt(modalDurationSelect.value) || 30;
                }

                if (type === 'daily') {
                    newTask.dailyId = 'daily-' + (++dailyTaskCounter);
                    newTask.pattern = 'daily';
                } else if (type === 'custom') {
                    const selectedDays = getSelectedModalDays();
                    if (selectedDays.length === 0) {
                        alert('Please select at least one day');
                        return;
                    }
                    newTask.dailyId = 'daily-' + (++dailyTaskCounter);
                    newTask.pattern = selectedDays.join(',');
                } else if (type === 'every-n-days') {
                    const interval = parseInt(modalEveryNDaysInput.value) || 2;
                    if (interval < 2 || interval > 30) {
                        alert('Please enter a number between 2 and 30');
                        return;
                    }
                    newTask.dailyId = 'daily-' + (++dailyTaskCounter);
                    newTask.repeatInterval = interval;
                    newTask.startDate = modalDateInput.value || formatDateForInput(viewingDate);
                } else if (type === 'monthly') {
                    const monthlyDay = parseInt(modalMonthlyDaySelect.value) || 1;
                    newTask.dailyId = 'daily-' + (++dailyTaskCounter);
                    newTask.monthlyDate = monthlyDay;
                } else {
                    // One-time
                    const date = modalDateInput.value;
                    if (!date) {
                        alert('Please select a date');
                        return;
                    }
                    newTask.date = date;
                }

                tasks.push(newTask);
                saveData();
            }

            closeCreateTaskModal();

            // Save scroll position before re-render (especially important for Plan view on mobile)
            const scrollY = window.scrollY;
            renderCurrentView();
            // Restore scroll position after render
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollY);
            });

            // Refresh bottom sheet if open
            if (bottomSheet.classList.contains('open')) {
                renderBottomSheetTasks();
            }
        }

        // Swipe Gestures for Day View
        function setupSwipeGestures() {
            // Day view swipe
            dayViewContainer.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            dayViewContainer.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleDaySwipe();
            }, { passive: true });

            // Week view swipe - only on desktop (mobile uses horizontal scroll for days)
            weekViewContainer.addEventListener('touchstart', e => {
                // Skip on mobile - horizontal scroll is for day navigation
                if (window.innerWidth < 768) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            weekViewContainer.addEventListener('touchend', e => {
                // Skip on mobile - horizontal scroll is for day navigation
                if (window.innerWidth < 768) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleWeekSwipe();
            }, { passive: true });
        }

        function handleDaySwipe() {
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;

            // Only register horizontal swipes (not vertical scrolling)
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX > 0) {
                    navigateDay(1); // Swipe left → next day
                } else {
                    navigateDay(-1); // Swipe right → previous day
                }
            }
        }

        function handleWeekSwipe() {
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;

            // Only register horizontal swipes (not vertical scrolling)
            if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > SWIPE_THRESHOLD) {
                if (diffX > 0) {
                    navigateWeek(1); // Swipe left → next week
                } else {
                    navigateWeek(-1); // Swipe right → previous week
                }
            }
        }

        // Bottom sheet swipe down to close
        function setupBottomSheetGestures() {
            let sheetTouchStartY = 0;

            bottomSheet.addEventListener('touchstart', e => {
                sheetTouchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            bottomSheet.addEventListener('touchend', e => {
                const sheetTouchEndY = e.changedTouches[0].screenY;
                const diff = sheetTouchEndY - sheetTouchStartY;

                if (diff > 100) {
                    closeBottomSheet();
                }
            }, { passive: true });
        }

        // Data Persistence
        function saveData() {
            console.log('[DEBUG] saveData called - isCompletingWeekTask:', isCompletingWeekTask);
            const data = {
                tasks: tasks,
                xp: totalXp,
                dailyTaskCounter: dailyTaskCounter,
                taskIdCounter: taskIdCounter,
                completions: taskCompletions,
                achievements: unlockedAchievements
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            
            // Trigger notification scheduler to pick up new/modified tasks
            if (typeof window.triggerSchedulerRescan === 'function') {
                window.triggerSchedulerRescan();
            }
        }

        function loadData() {
            const savedData = localStorage.getItem(STORAGE_KEY);
            if (!savedData) return;

            try {
                const data = JSON.parse(savedData);

                dailyTaskCounter = data.dailyTaskCounter || 0;
                taskIdCounter = data.taskIdCounter || 0;
                taskCompletions = data.completions || {};
                unlockedAchievements = data.achievements || {};

                // Load tasks - handle migration from old format
                if (data.tasks && Array.isArray(data.tasks)) {
                    // Check if old format (tasks have dayIndex)
                    if (data.tasks.length > 0 && data.tasks[0].dayIndex !== undefined) {
                        // Migrate from old format
                        tasks = migrateOldTasks(data.tasks);
                    } else {
                        tasks = data.tasks;
                    }

                    // Migrate tasks without category (add default "general" category)
                    tasks.forEach(task => {
                        if (!task.category) {
                            task.category = 'general';
                        }
                    });
                }

                // Recalculate XP from completions + achievements
                totalXp = recalculateXpFromCompletions();
                totalXp += calculateAchievementXp();
                // Sync previousLevel to prevent false celebration on load
                const currentLevel = getLevel(totalXp);
                previousLevel = currentLevel;
                localStorage.setItem(LEVEL_STORAGE_KEY, currentLevel.toString());
                updateLevelDisplay();
            } catch (e) {
                console.error('Error loading saved data:', e);
            }
        }

        function calculateAchievementXp() {
            let achievementXp = 0;
            for (const achievementId in unlockedAchievements) {
                // Find achievement by id
                const allAchievements = [...ACHIEVEMENTS.streak, ...ACHIEVEMENTS.completion];
                const achievement = allAchievements.find(a => a.id === achievementId);
                if (achievement) {
                    achievementXp += achievement.xp;
                }
            }
            return achievementXp;
        }

        function migrateOldTasks(oldTasks) {
            const migratedTasks = [];
            const seenDailyIds = new Set();

            oldTasks.forEach(task => {
                // For recurring tasks, only add once
                if (task.dailyId) {
                    if (seenDailyIds.has(task.dailyId)) return;
                    seenDailyIds.add(task.dailyId);

                    migratedTasks.push({
                        id: task.id,
                        name: task.name,
                        type: task.pattern === 'daily' ? 'daily' : 'custom',
                        dailyId: task.dailyId,
                        pattern: task.pattern
                    });
                } else {
                    // One-time task
                    migratedTasks.push({
                        id: task.id,
                        name: task.name,
                        type: 'onetime',
                        date: task.fullDate || formatDateForInput(new Date())
                    });
                }
            });

            return migratedTasks;
        }

        function loadView() {
            const savedView = localStorage.getItem(VIEW_STORAGE_KEY);
            const isMobile = window.innerWidth < 600;

            if (savedView) {
                setView(savedView);
            } else {
                setView(isMobile ? 'day' : 'week');
            }
        }

        // Event Listeners Setup
        function setupEventListeners() {
            // Date navigation
            prevDateBtn.addEventListener('click', () => {
                if (currentView === 'month') {
                    changeMonth(-1);
                } else if (currentView === 'week') {
                    navigateWeek(-1);
                } else {
                    navigateDay(-1);
                }
            });

            nextDateBtn.addEventListener('click', () => {
                if (currentView === 'month') {
                    changeMonth(1);
                } else if (currentView === 'week') {
                    navigateWeek(1);
                } else {
                    navigateDay(1);
                }
            });

            todayBtn.addEventListener('click', goToToday);

            // View toggle
            dayViewBtn.addEventListener('click', () => setView('day'));
            weekViewBtn.addEventListener('click', () => setView('week'));
            monthViewBtn.addEventListener('click', () => setView('month'));
            planViewBtn.addEventListener('click', () => setView('plan'));
            statsViewBtn.addEventListener('click', () => setView('stats'));

            // Week navigation bottom bar button handlers
            if (weekNavPrev) {
                weekNavPrev.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[Week Nav] Prev button clicked');
                    navigateWeek(-1);
                });
            }

            if (weekNavNext) {
                weekNavNext.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('[Week Nav] Next button clicked');
                    navigateWeek(1);
                });
            }

            // Plan view navigation
            planPrevWeek.addEventListener('click', () => navigatePlanWeek(-1));
            planNextWeek.addEventListener('click', () => navigatePlanWeek(1));

            // Plan help button and overlay
            planHelpBtn.addEventListener('click', () => {
                planHelpOverlay.classList.add('active');
            });
            planHelpOverlay.addEventListener('click', () => {
                planHelpOverlay.classList.remove('active');
            });

            // Task detail modal
            taskDetailClose.addEventListener('click', closeTaskDetailModal);
            taskDetailModal.addEventListener('click', (e) => {
                if (e.target === taskDetailModal) {
                    closeTaskDetailModal();
                }
            });
            taskDetailEditBtn.addEventListener('click', () => {
                const taskId = currentDetailTaskId;
                const dateStr = currentDetailDateStr;
                closeTaskDetailModal();
                openEditTaskModal(taskId, dateStr);
            });

            // FAB
            fabButton.addEventListener('click', () => {
                if (createTaskModal.classList.contains('active')) {
                    closeCreateTaskModal();
                } else {
                    openCreateTaskModal();
                }
            });

            // Modal
            modalCloseBtn.addEventListener('click', closeCreateTaskModal);
            createTaskModal.addEventListener('click', (e) => {
                if (e.target === createTaskModal) {
                    closeCreateTaskModal();
                }
            });

            modalCategorySelect.addEventListener('change', () => {
                const category = modalCategorySelect.value;
                categoryIndicator.style.background = getCategoryColor(category);
            });

            modalTypeSelect.addEventListener('change', () => {
                const type = modalTypeSelect.value;
                // Hide all conditional fields first
                modalDateField.style.display = 'none';
                modalEveryNDaysField.style.display = 'none';
                modalMonthlyField.style.display = 'none';
                modalDayPickerField.style.display = 'none';

                // Show relevant fields based on type
                if (type === 'onetime') {
                    modalDateLabel.textContent = 'Date';
                    modalDateField.style.display = 'block';
                } else if (type === 'every-n-days') {
                    modalDateLabel.textContent = 'Starting from';
                    modalEveryNDaysField.style.display = 'block';
                    modalDateField.style.display = 'block'; // Start date
                } else if (type === 'monthly') {
                    modalMonthlyField.style.display = 'block';
                } else if (type === 'custom') {
                    modalDayPickerField.style.display = 'block';
                }
                // 'daily' shows no extra fields
            });

            modalDayPicker.querySelectorAll('.modal-day-toggle').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('selected');
                });
            });

            // Time toggle
            modalTimeToggle.addEventListener('change', () => {
                timeInputWrapper.style.display = modalTimeToggle.checked ? 'block' : 'none';
            });

            modalSubmitBtn.addEventListener('click', addTask);
            modalTaskInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addTask();
            });

            // Notes textarea character count
            modalNotesInput.addEventListener('input', updateNotesCharCount);

            // Notes modal
            notesModalClose.addEventListener('click', closeNotesModal);
            notesModalCancelBtn.addEventListener('click', closeNotesModal);
            notesModalSaveBtn.addEventListener('click', saveNotes);
            notesModal.addEventListener('click', (e) => {
                if (e.target === notesModal) {
                    closeNotesModal();
                }
            });

            // Bottom sheet
            bottomSheetOverlay.addEventListener('click', closeBottomSheet);
            sheetCloseBtn.addEventListener('click', closeBottomSheet);

            // Reset achievements
            if (resetAchievementsBtn) {
                resetAchievementsBtn.addEventListener('click', showResetConfirmation);
            }
            if (confirmCancel) {
                confirmCancel.addEventListener('click', hideResetConfirmation);
            }
            if (confirmReset) {
                confirmReset.addEventListener('click', resetAchievements);
            }
            if (confirmOverlay) {
                confirmOverlay.addEventListener('click', (e) => {
                    if (e.target === confirmOverlay) hideResetConfirmation();
                });
            }

            // Fallback: Event delegation for reset button
            document.addEventListener('click', (e) => {
                if (e.target && (e.target.id === 'resetAchievementsBtn' || e.target.classList.contains('achievements-reset-btn'))) {
                    showResetConfirmation();
                }
            });

            // ESC key to close modals
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (taskDetailModal.classList.contains('active')) {
                        closeTaskDetailModal();
                    } else if (notesModal.classList.contains('active')) {
                        closeNotesModal();
                    } else if (createTaskModal.classList.contains('active')) {
                        closeCreateTaskModal();
                    } else if (deleteModal.classList.contains('active')) {
                        closeDeleteModal();
                    } else if (bottomSheet.classList.contains('open')) {
                        closeBottomSheet();
                    }
                }
            });

            // Swipe gestures
            setupSwipeGestures();
            setupBottomSheetGestures();
        }

        function changeMonth(delta) {
            let targetMonth = viewingMonth + delta;
            let targetYear = viewingYear;

            if (targetMonth > 11) {
                targetMonth = 0;
                targetYear++;
            } else if (targetMonth < 0) {
                targetMonth = 11;
                targetYear--;
            }

            viewingMonth = targetMonth;
            viewingYear = targetYear;
            viewingDate = new Date(viewingYear, viewingMonth, 1);

            // Update display
            updateDateDisplay();

            // Always re-render the grid view (desktop)
            renderMonthGridView();

            // For mobile: Check if target month is already loaded in infinite scroll
            const targetHeader = monthList.querySelector(`.month-header-separator[data-month="${targetMonth}"][data-year="${targetYear}"]`);

            if (targetHeader) {
                // Scroll to it
                targetHeader.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                // Re-render mobile view with new center month
                renderMonthListView();
            }
        }

        // Initialize
        function init() {
            loadData();
            setupEventListeners();
            loadView();
            updateDateDisplay();
        }

        init();

        // ============================================================
        // PWA + TASK REMINDER NOTIFICATIONS
        // ============================================================
        // How it works:
        //   • Registers the service worker (enables offline + push)
        //   • Shows a contextual banner guiding iPhone users through
        //     "Add to Home Screen" → grant notification permission
        //   • Once permission is granted, reads today's timed tasks
        //     from localStorage and sets a setTimeout for each one
        //   • Rescans every 5 min (in case tasks were added/completed)
        //   • Also rescans when the tab regains focus
        // iOS constraint: push notifications only work when the app
        //   is installed to the Home Screen (PWA standalone mode).
        // ============================================================

        (function pwaAndNotifications() {
            console.log('[NOTIF INIT] Starting notification initialization...');

            // --- 1. Register service worker ---
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').then(function (reg) {
                    console.log('[SW] registered, scope:', reg.scope);
                }).catch(function (err) {
                    console.log('[SW] registration failed:', err);
                });
            }

            // --- 2. Settings helpers ---
            var NOTIF_KEY = 'lifeGamifiedNotifSettings';

            function getSettings() {
                try {
                    var s = localStorage.getItem(NOTIF_KEY);
                    if (s) return JSON.parse(s);
                } catch (e) { /* ignore */ }
                return { enabled: false, minutesBefore: 5 };
            }

            function saveSettings(s) {
                localStorage.setItem(NOTIF_KEY, JSON.stringify(s));
            }

            // --- 3. Detect PWA install state ---
            function isInstalled() {
                return !!window.navigator.standalone ||
                       window.matchMedia('(display-mode: standalone)').matches;
            }

            // --- 4. Banner UI ---
            var banner = document.getElementById('notif-banner');
            var bannerDismissed = false;

            function renderBanner() {
                if (!banner || bannerDismissed) return;

                // Already fully set up? Hide permanently.
                if (isInstalled() && Notification.permission === 'granted') {
                    banner.style.display = 'none';
                    return;
                }

                var icon, title, sub, actionHtml;

                if (!isInstalled()) {
                    // Not installed → guide to Add to Home Screen
                    icon   = '📲';
                    title  = 'Get task reminders';
                    sub    = 'Tap the share button, then "Add to Home Screen."';
                    actionHtml = '';
                } else if (Notification.permission === 'default') {
                    // Installed but permission not yet asked
                    icon   = '🔔';
                    title  = 'Enable task reminders';
                    sub    = 'Get notified before your scheduled tasks.';
                    actionHtml = '<button class="notif-banner-btn" id="notifEnableBtn">Enable</button>';
                } else if (Notification.permission === 'denied') {
                    // Permission explicitly denied
                    icon   = '⚠️';
                    title  = 'Notifications are blocked';
                    sub    = 'Go to Settings → Life Gamified → Notifications.';
                    actionHtml = '';
                } else {
                    banner.style.display = 'none';
                    return;
                }

                banner.innerHTML =
                    '<div class="notif-banner-row">' +
                    '  <span class="notif-banner-icon">' + icon + '</span>' +
                    '  <div class="notif-banner-text">' +
                    '    <strong>' + title + '</strong>' +
                    '    <span>' + sub + '</span>' +
                    '  </div>' +
                    '  ' + actionHtml +
                    '  <button class="notif-banner-close" id="notifCloseBtn">✕</button>' +
                    '</div>';
                banner.style.display = 'flex';

                // Wire up buttons (re-bind each time banner is rendered)
                var closeBtn = document.getElementById('notifCloseBtn');
                if (closeBtn) closeBtn.addEventListener('click', function () {
                    bannerDismissed = true;
                    banner.style.display = 'none';
                });

                var enableBtn = document.getElementById('notifEnableBtn');
                if (enableBtn) enableBtn.addEventListener('click', function () {
                    if (!('Notification' in window)) return;
                    Notification.requestPermission().then(function (perm) {
                        if (perm === 'granted') {
                            var s = getSettings();
                            s.enabled = true;
                            saveSettings(s);
                            startScheduler();
                            renderBanner(); // re-render → will hide
                            // Show confirmation using the existing undo-toast element
                            var toast = document.getElementById('undoToast');
                            var msg   = document.getElementById('undoToastMessage');
                            if (toast && msg) {
                                msg.textContent = 'Task reminders enabled ✓';
                                toast.classList.add('visible');
                                setTimeout(function () { toast.classList.remove('visible'); }, 2200);
                            }
                        } else {
                            renderBanner(); // re-render → shows "blocked" state
                        }
                    });
                });
            }

            // --- 5. Scheduler core ---
            var activeTimers = [];
            var rescanInterval = null;

            // Mirror the app's weekday mapping: Mon=0 … Sun=6
            function isoWeekday(date) {
                var d = date.getDay(); // JS: Sun=0 … Sat=6
                return d === 0 ? 6 : d - 1;
            }

            function dateKey(date) {
                var y = date.getFullYear();
                var m = String(date.getMonth() + 1).padStart(2, '0');
                var d = String(date.getDate()).padStart(2, '0');
                return y + '-' + m + '-' + d;
            }

            // Returns true if `task` should appear on `date`.
            // Mirrors getTasksForDate() in the main app exactly.
            function taskAppearsOn(task, date) {
                var dateStr = dateKey(date);
                var weekday = isoWeekday(date);

                switch (task.type) {
                    case 'daily':
                        return true;

                    case 'custom':
                        if (!task.pattern) return false;
                        var days = task.pattern.split(',').map(Number);
                        return days.indexOf(weekday) !== -1;

                    case 'every-n-days':
                        if (!task.startDate || !task.repeatInterval) return false;
                        var start   = new Date(task.startDate + 'T00:00:00');
                        var current = new Date(dateStr + 'T00:00:00');
                        var diff    = Math.round((current - start) / 86400000);
                        return diff >= 0 && diff % task.repeatInterval === 0;

                    case 'monthly':
                        if (!task.monthlyDate) return false;
                        var dom = date.getDate();
                        var lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                        if (task.monthlyDate > lastDay) return dom === lastDay;
                        return dom === task.monthlyDate;

                    default: // 'onetime' or anything else
                        return task.date === dateStr;
                }
            }

            function scheduleReminders() {
                console.log('[SCHEDULER] scheduleReminders() called');
                var settings = getSettings();
                console.log('[SCHEDULER] settings:', settings);
                if (!settings.enabled) {
                    console.log('[SCHEDULER] Exiting - not enabled');
                    return;
                }
                if (Notification.permission !== 'granted') {
                    console.log('[SCHEDULER] Exiting - permission not granted');
                    return;
                }

                // Clear previous timers
                activeTimers.forEach(function (id) { clearTimeout(id); });
                activeTimers = [];

                // Read fresh data from localStorage
                var raw;
                try { raw = JSON.parse(localStorage.getItem('lifeGamifiedData')); } catch (e) { 
                    console.log('[SCHEDULER] No task data found');
                    return; 
                }
                if (!raw || !raw.tasks) {
                    console.log('[SCHEDULER] No tasks in data');
                    return;
                }

                var now         = new Date();
                var todayStr    = dateKey(now);
                var completions = raw.completions || {};
                
                console.log('[SCHEDULER] Processing', raw.tasks.length, 'tasks for today:', todayStr);

                raw.tasks.forEach(function (task) {
                    // Only care about tasks that have a scheduled time
                    if (!task.time) return;
                    // Only care about tasks appearing today
                    if (!taskAppearsOn(task, now)) return;

                    // Check completion.  Key structure: completions[taskId][dateStr]
                    var taskId = task.dailyId || task.id;
                    var compDate = (task.type === 'onetime') ? task.date : todayStr;
                    if (completions[taskId] && completions[taskId][compDate]) return;

                    // Calculate reminder fire time
                    var parts = task.time.split(':');
                    var h = parseInt(parts[0], 10);
                    var m = parseInt(parts[1], 10);

                    var fireAt = new Date(now);
                    fireAt.setHours(h, m - settings.minutesBefore, 0, 0);

                    // If fire time already passed, skip
                    if (fireAt <= now) return;

                    var delayMs = fireAt.getTime() - now.getTime();

                    var timerId = setTimeout(function () {
                        console.log('[SCHEDULER] Timer fired for task:', task.name);
                        // Re-check completion at fire time (user may have finished the task)
                        var fresh;
                        try { fresh = JSON.parse(localStorage.getItem('lifeGamifiedData')); } catch (e) {}
                        var freshComp = (fresh && fresh.completions) || {};
                        if (freshComp[taskId] && freshComp[taskId][compDate]) return; // done — skip

                        var label = settings.minutesBefore > 0
                            ? 'Starting in ' + settings.minutesBefore + ' min (' + task.time + ')'
                            : 'Scheduled for ' + task.time;

                        console.log('[SCHEDULER] Showing notification:', task.name, '-', label);
                        new Notification(task.name, {
                            body:  label,
                            icon:  '/icons/icon-192.png',
                            badge: '/icons/icon-192.png',
                            tag:   'task-' + taskId + '-' + todayStr,
                            data:  { url: '/' }
                        });
                    }, delayMs);

                    activeTimers.push(timerId);
                    console.log('[SCHEDULER] Timer set for', task.name, 'at', fireAt.toLocaleTimeString(), '(in', Math.round(delayMs/1000), 'seconds)');
                });
                
                console.log('[SCHEDULER] Total timers set:', activeTimers.length);
            }

            function startScheduler() {
                console.log('[SCHEDULER] startScheduler() called');
                if (rescanInterval) {
                    console.log('[SCHEDULER] Already running, skipping');
                    return; // already running
                }
                scheduleReminders();
                rescanInterval = setInterval(scheduleReminders, 300000); // every 5 min
                console.log('[SCHEDULER] Rescan interval set (every 5 min)');
            }
            
            // Expose to global scope so saveData() can trigger rescans
            window.triggerSchedulerRescan = function() {
                console.log('[SCHEDULER] Manual rescan triggered by saveData()');
                scheduleReminders();
            };

            // --- 6. Init sequence ---

            // Show banner after a short delay so it doesn't block first paint
            setTimeout(renderBanner, 1800);

            // If notifications were already enabled in a previous session, start scheduling
            console.log('[NOTIF INIT] Checking if scheduler should start...');
            var currentSettings = getSettings();
            console.log('[NOTIF INIT] currentSettings:', currentSettings);
            console.log('[NOTIF INIT] currentSettings.enabled:', currentSettings.enabled);
            console.log('[NOTIF INIT] Notification.permission:', Notification.permission);
            console.log('[NOTIF INIT] Both conditions true?', currentSettings.enabled && Notification.permission === 'granted');
            
            if (currentSettings.enabled && Notification.permission === 'granted') {
                console.log('[NOTIF INIT] ✓ Starting scheduler NOW!');
                startScheduler();
                console.log('[NOTIF INIT] ✓ Scheduler started!');
            } else {
                console.log('[NOTIF INIT] ✗ Scheduler NOT started. Reason:', !currentSettings.enabled ? 'enabled=false' : 'permission not granted');
            }

            // Rescan when tab comes back to foreground (e.g. user returns from Safari)
            document.addEventListener('visibilitychange', function () {
                if (!document.hidden) {
                    var s = getSettings();
                    if (s.enabled && Notification.permission === 'granted') {
                        scheduleReminders();
                    }
                    // Also re-check banner in case install state changed
                    renderBanner();
                }
            });

        })(); // end pwaAndNotifications IIFE

    </script>

    <!-- Supabase Auth -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script type="module">
        import { signUp, signIn, signOut, getCurrentUser, onAuthStateChange } from './auth.js';

        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const authForm = document.getElementById('auth-form');
        const authEmail = document.getElementById('auth-email');
        const authPassword = document.getElementById('auth-password');
        const authSubmitBtn = document.getElementById('auth-submit-btn');
        const authError = document.getElementById('auth-error');
        const authToggle = document.getElementById('auth-toggle');
        const signOutBtn = document.getElementById('sign-out-btn');

        let isSignUpMode = false;

        function showApp() {
            authContainer.style.display = 'none';
            appContainer.style.display = '';
            console.log('[auth-ui] App shown');
        }

        function showAuth() {
            authContainer.style.display = '';
            appContainer.style.display = 'none';
            console.log('[auth-ui] Auth screen shown');
        }

        function showError(msg) {
            authError.textContent = msg;
            authError.style.display = 'block';
        }

        function clearError() {
            authError.textContent = '';
            authError.style.display = 'none';
        }

        // Toggle between sign-in and sign-up
        authToggle.addEventListener('click', () => {
            isSignUpMode = !isSignUpMode;
            clearError();
            if (isSignUpMode) {
                authSubmitBtn.textContent = 'Sign Up';
                authToggle.innerHTML = 'Already have an account?<span>Sign in</span>';
                authPassword.setAttribute('autocomplete', 'new-password');
            } else {
                authSubmitBtn.textContent = 'Sign In';
                authToggle.innerHTML = "Don't have an account?<span>Sign up</span>";
                authPassword.setAttribute('autocomplete', 'current-password');
            }
        });

        // Handle form submission
        authForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            clearError();

            const email = authEmail.value.trim();
            const password = authPassword.value;

            if (!email || !password) {
                showError('Please enter both email and password.');
                return;
            }

            authSubmitBtn.disabled = true;
            authSubmitBtn.textContent = isSignUpMode ? 'Signing up...' : 'Signing in...';

            const { data, error } = isSignUpMode
                ? await signUp(email, password)
                : await signIn(email, password);

            authSubmitBtn.disabled = false;
            authSubmitBtn.textContent = isSignUpMode ? 'Sign Up' : 'Sign In';

            if (error) {
                showError(error.message);
                return;
            }

            // If sign-up requires email confirmation
            if (isSignUpMode && data?.user && !data.session) {
                showError('Check your email to confirm your account, then sign in.');
                isSignUpMode = false;
                authSubmitBtn.textContent = 'Sign In';
                authToggle.innerHTML = "Don't have an account?<span>Sign up</span>";
                authPassword.setAttribute('autocomplete', 'current-password');
                return;
            }

            showApp();
        });

        // Sign-out button
        signOutBtn.addEventListener('click', async () => {
            const { error } = await signOut();
            if (error) {
                console.log('[auth-ui] Sign out error:', error.message);
            }
            showAuth();
            authEmail.value = '';
            authPassword.value = '';
            clearError();
        });

        // Listen for auth state changes
        onAuthStateChange((event, session) => {
            console.log('[auth-ui] Auth state change:', event);
            if (event === 'SIGNED_IN' && session) {
                showApp();
            } else if (event === 'SIGNED_OUT') {
                showAuth();
            }
        });

        // Check if user is already logged in on page load
        (async () => {
            const user = await getCurrentUser();
            if (user) {
                console.log('[auth-ui] User already logged in:', user.id);
                showApp();
            } else {
                console.log('[auth-ui] No active session, showing auth screen');
                showAuth();
            }
        })();
    </script>
</body>
</html>
